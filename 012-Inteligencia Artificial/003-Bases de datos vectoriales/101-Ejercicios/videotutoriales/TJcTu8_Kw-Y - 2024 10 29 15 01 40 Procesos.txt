vale un poco en cierta forma continuando el ejercicio de ayer pero ahora desde el punto de vista desde el punto de vista segundo servicios y procesos voy a ir a comunicaciones de red el otro día creo que estuvimos tocando aquí no espera sockets vale creación de sockets enlazado y establecimiento de Comunicaciones y aquí dentro en archivo nuevo voy a hacer un 001 en primer lugar quiero hablar un poquito de memoria es decir ayer estuvimos comentando que quizás uno de los problemas que habíamos tenido la semana pasada con respecto al sistema de videoconferencia era que estábamos enviando fotogramas enteros La pregunta es podemos enviar Trozos de fotogramas podemos enviar información comprimida Cómo podemos comprimir vale antes de comprimir nos tenemos que preguntar cuánto ocupa lo que estamos enviando Y esa es una pregunta que hasta ahora no la hemos sabido responder Vale entonces eh cuánto ocupa un array html en Chrome al igual que en algunos entornos de desarrollo pero en este caso en Chrome se puede pues eh podemos averiguar cuánto ocupa una estructura de datos ya que al final sabemos que vamos a enviar estructuras de datos Así que creo un archivo básico Bueno voy a crear directamente un Body Vale y dentro del Body en javascript voy a decir que led eh colección es igual a por ejemplo 1 2 3 4 5 6 7 8 ya está y ahora a continuación lo que quiero hacer es averiguar Cuánta memoria ocupa exactamente este array es decir Si yo envío este array a un servidor a través de sockets o a través de red Cuánta memoria estoy enviando Más que nada porque el rendimiento del sistema Pues también va a depender de la memoria que estemos utilizando vale Así que me voy a chromium me voy a chat gpt y me voy al Memory performance e averiguar Cuánta memoria consume una ray en Chrome o no de js Entonces vamos a ver digo en Chrome en no Djs porque como javascript es un lenguaje interpretado por el navegador esto es Eh como es un lenguaje interpretado por el navegador Pues claro cada motor de cada navegador puede gastar una cantidad de memoria diferente entonces en mi caso lo que voy a hacer es Esto vale vamos a ver process y aquí Vale entonces inicial momentín voy a decir que memoria inicial es esto memoria final es esto y voy a sacar el diferencial memoria final es esto y ahora a continuación pues utilizada es igual a final menos inicial Así que vamos allá Ya está vale Ok vale Y esto bueno partido 1024 vale Esto me va a dar esto es kilobytes Y esto es bytes vale me va a dar los bytes me vuelvo a Chrome me voy a local Host me voy a dam me voy a segundo hasta ahora nunca nos hemos preocupado de Cuánta rama ocupaban los programas que estábamos creando vale pero claro ahora pues ya va empezando a ser el momento Así que comunicaciones de red entonces enlazado Y cuánto ocupa un aray y me vengo por aquí process process a ver un momento y no de js perdón performance aquí performance Memory lo anterior era en node Así que performance vale Y ya está bien Vamos allá recargamos y Ah Sí perdón vale fantástico y console pun log memoria utilizada vale me dice cero Okay performance final menos inicial voy a meter más cosas me dice que ocupa cer bytes lo cual me extraña vamos a meter por aquí más información me sigue diciendo cero me sigue diciendo cero a ver vale partido 1024 voy a hacer una cosa voy a hacer esto voy a meter una Ray con un montón de elementos un e a la 6 básicamente es un millón de elementos recargo cero no puede ser vamos a ver momentín y vale puede diferir Okay forzar asignación vale Okay vamos a probarlo usar una pausa esa me gusta un poquito más esa me gusta un poquito más okay esta me gusta un poquito más vamos a verlo Ahora sí vale la memoria utilizada ha sido de 3,8 MB de hecho ahora vamos a empezar por algo más sencillo vamos a empezar por 1 2 3 4 5 6 7 8 porque probable ente no estáis muy familiarizados con la noción científica que estaba poniendo antes con lo cual pues creo una Ray de ocho elementos aquí de hecho vamos a ver console log memoria utilizada vale quiero directamente nos ahorramos todo esto no quiero que me lo conviertas a megabytes quiero Esto vale Ahora sí los bytes que he utilizado ahora mismo son 4612 si yo ahora vengo por aquí y digo que le meto más coma coma coma ahora quito ese elemento alfanumérico guardo vale 4612 recargo y ahora son 4344 y vamos a ver evidentemente que esto va a ir creciendo conforme yo vaya asignando Es decir eh 002 a raí grandes y ahora a continuación digo led collec es igual a nada Y entonces for led i es igual a 0 Y es menor que TR 300,000 vale Y más y entonces vengo por aquí y digo eh colección punto Push y voy a poner un cero vale pongo un número cero Así que si creo una Ray de 10.000 elementos a ver espera la sangría va Aquí creo una Ray de 100.000 elementos pues me dice 137000 bytes pero si es de 100,000 elementos Entonces es 530,000 pero si es de 1 millón de elementos Entonces es 1 487000 vale Así que En definitiva vemos có eh pues podemos empezar a estimar Cuánto pesa una rray concreto bien Ahora vamos a hacer una aplicación más práctica y ahora 003 cuánto pes el array de una imagen entonces Yo vengo por aquí y me creo un Canvas me creo un Canvas eh tengo alguna imagen por ahí siempre a mano mía entonces me voy a escritorio me voy a archivar y cojo alguna imagen mía Aquí esta no esta Sí vale dam segundo servicios y procesos comunicaciones de red enlazado pego la llamo José Vicente vale Y jpeg no jpg la imagen ocupa no es muy grande 200 por 200 vale lo que sea entonces digo vamos a ver entonces digo led colección nada vale Cuánto pesa la imagen y digo const Lienzo es igual a document.get Element no query selector Canvas ahora const contexto es igual a Lienzo getcontext 2D ahora Lienzo pun with es ig a 200 Lienzo pun height es ig a y por lo tanto ahora digo led imagen es igual a New image imagen src es igual a José viicente jpg y contexto draw image Eh quiero pegar imagen en 0,0 con lo cual Bueno de hecho aquí puedo poner un imagen pun onload function para asegurar que no se ejecute hasta que no cargue la imagen vale Y vamos a ver Esto si esto funciona correctamente me vengo por aquí Cuánto pesa Vale tengo la imagen ahí puesta y ahora a continuación claro Esto vale correcto y ahora a continuación Bueno aquí técnicamente ya veo el un principio digamos de memoria vale Y ahora a continuación digo OK Vamos a ver aquí y ahora digo inicial es inicial en este punto vale o sea le ha costado 58000 bytes 58 cas cargar la imagen vale correcto pero yo no quiero eso yo lo que quiero es saber cuánto te cuesta cargar el array de la imagen así que digo con colección es igual a contexto get image Data desde 0,0 hasta 200,200 Y si queréis punto Data ya que estamos y ahora sí y ahora cojo el const inicial Ah espérate esto aquí y ahora hago un Time out vamos a verlo vale es decir inicial memoria en este momento cargo la colección espero 100 milisegundos y vuelvo a mirar la memoria y me dice que creo que es el mismo en el que estoy vale me dice que la memoria que estoy utilizando son 181 kb qué tiene esa ese elemento qué tiene memoria pues colección aquí por ejemplo da igual donde lo ponga eh Mira voy a ponerlo aquí después del console pun log colección vale 160 cas aproximadamente puede variar un poco vale Y ahora aquí y veo que lo que tengo como ya sabemos es una Ray de elementos vale a continuación lo que podemos hacer es eh averiguar Cuáles de estos elementos son iguales entre sí en una foto esto no va a tener ningún significado pero en una captura de pantalla sí que vamos a ver que hay una serie de patrones que se repiten Así que yo voy a cargar Por ejemplo Esto me voy a vo a cargar una captura de pantalla voy a hacer una captura de pantalla voy a hacer así imaginemos que envío Esto vale Eh Así yo que sé o pantalla sabes pantalla completa catap pantalla completa Dónde está esto en archivos vale lo cargo me lo paso a aquí vale esto es captura.png Y entonces a continuación me voy a hacer lo mismo pero con la captura de pantalla ahora 004 captura de pantalla entonces bueno no pasa nada Simplemente esto es captura.png esto es 1920 esto es 1080 vale Si yo envío pantallazos a través de la red Cuánta memoria van a ocupar los pantallazos pues vamos a verlo 00 1920 1080 vale Y ya está eh voy a quitar esto un momento vale probamos captura vale me dice que ocupa ojo esto ya es otra cosa eh esto ya es otra cosa esto son 8 megas ocupa 8 megas este archivo no ocupa 8 megas ocupa 95k por la sencilla razón de que está en png pero claro si no lo comprimo en png sino que lo guardo por ejemplo en bmp José viicente bmp y me voy a la carpeta Pues claro en bmp son 6,2 megas es decir cuando la semana pasada estábamos enviando vídeo estábamos haciendo la barbaridad de enviar descomprimido Claro Con razón se petaba el servidor vale lo que me extraña es que no se petara antes porque primero Sí vale lo he insisti unas cuantas veces es un servidor pequeño pero es que estamos enviando información a lo bestia vale siempre que hemos trabajado con información de Canvas hemos trabajado con información a hestia que cuando trabajamos dentro de nuestro propio equipo Pues bueno pues igual no se nota tanto pero cuando usamos la red pues obviamente sí que ahora hago cons sol log colección recargo hago así hago así y digo Ah Espérate un segundo qué veis aquí qu veis aquí 98 146 24255 986 2425 digo esto se repite en elío información no se repite tanto pero en una captura de pantalla y si yo quiero hacer ahora un sistema de videoconferencia pues la información se repite A qué corresponde esto Bueno pues esto claramente estas cuatro piezas de información corresponden a un píxel verde qué píxel verde pues este píxel verde de aquí por qué se repite Pues porque tengo un montón de píxeles que son iguales con lo cual digo Ah espérate porque si los píxeles son iguales Pues espérate porque igual puedo hacer otra cosa Vale puedo intentar digamos eh estimar la información vale además ocurre que de cada cuatro piezas de información El Alfa no me vale porque el alfa es transparencia igual en otro escenario utilizaré la transparencia pero es que ahora mismo no voy a usar la transparencia Entonces qué voy a hacer Bueno pues tengo ahora mismo acordaos porque yo no me voy a acordar eh o Aquí está eh 8000 Perdona 8294 o sea básicamente casi tengo pues la misma memoria que estáis viendo aquí porque me ocupa un byte por cada número un byte que es un número de 0 255 vale ocupará un poquito más por el alojamiento de memoria Así que una imagen la captura de pander desc comprimida son 8 megas acordaos 8,3 meg vale acordaos porque yo no me voy a acordar porque tengo memoria de pez entonces a partir de aquí ahora digo vale 005 quito el canal Alfa y a ver cuánto ocupa entonces vengo por aquí esto es eh colección vale Y entonces digo mm vamos a ver const sin transparencia es igual estoy usando const porque ya sabéis que tiende a usar menos memoria que led y que bar y ya sabéis que hoy el consumo de memoria es un tema importante ahora mismo en esta clase entonces digo con sin transparencia es igual a Rey vacío Y entonces for Let I es igual a 0 Y es menor que colección Espera que colección punto leng y más y entonces digo sin transparencia punto Push colección de I el I es más igual a 4 os acordáis para repasar píxel a píxel i + 1 e i + 2 Vale entonces ahora le voy a decir mídeme la memoria antes de esto ahora mídeme la memoria antes de esto y mí la memoria después de esto es decir ahora el punto inicial va a estar esto es eh 006 cuánto ocupa ahora vale vamos a verlo acordaos antes era 8 con3 creo 8,3 megas Oye pues Espérate no 25 megas tú crees vale vamos a ver ahora Hay un problema ahora Hay un problema me ocupa más porque cada uno de estos datos Debería ser de ocho mira aquí Debería ser aquí el Memory Inspector Ahí estás ahí está el problema vale Debería ser de 8 bytes pero en lugar de ser de 8 bytes está siendo de más vale por eso me ocupa ahora mismo 25 meg Pero qué ocurre que hasta la clase de hoy que estamos usando el Memory Inspector igual le estábamos quitando el canal Alfa a un elemento Mirad voy a ejecutar el anterior y el anterior me dice es un u int 8 vale int 8 clamp array es decir es una array de números enteros de ocho vale con lo cual diréis bueno Y ahora qué hacemos me ocupa 24 megas No pasa nada vamos a forzar el tipo Vale entonces 007 forzar forzamos enteros de 8 bits y vamos a verlo y eh convert js array to u in 8 array vamos a ver Okay Ok Okay Vale Sí muy bien y pues ya está Vale aquí hago así un momento aquí y digo e vamos a ver bueno sin transparencia es igual a u in raí de sin transparencia con lo cual vamos a ver ahora miro la memoria aquí miro la memoria después y ya está a ver y vale venga vamos a por ello recargo fuerzo Hola sin transparencia Vale y sin transparencia Ok recargo assignment constant variable Perdón Let vale Wow menos número negativo no puede ser vamos a ver encia 8 con sin transparencia vamos a usar otra Estructura de datos menos Tal imposible vamos a ver inicial es igual a esto final es igual a esto Estos son -58 megas 1 2 3 - 58 megas vamos a ver claro está usando -58 meg porque me está descargando Esa ese array vale vamos a ver nada estoy pensando en cómo porque lo que está haciendo básicamente es o sea como el programa el navegador no es de sacar directamente cuánto ocupa una Ray lo que está haciendo es averiguar la diferencia entre memoria antes y después pero problema en el momento en el que ya no estoy usando esto pues ya no me lo descarga o sea Perdón me lo descarga de la memoria y al descargar de la memoria me da un número negativo y me pervierte el número vale lo que me importa eso sí lo que me importa eso sí es que transparencia console log colección sin transparencia recargo y nos fijamos como en este caso aquí 16 nos fijamos como en este caso me está dando 6 220.000 Es decir me ha descargado un 25% me ha descargado el alfa vamos a suponer que este número está bien y vamos a continuar Vale entonces para ello un momentín a ver si puedo hacer esto inicial es igual a esto colección es igual a esto a ver ahora no creo vale Y esto es led no otra cosa que puedo hacer vale no es esperar un poco pero bueno ya está vale No pasa nada vamos a por ello bien vemos que ahora la información se repite 98 146 24 vale claro yo ahora a continuación voy a implementar un algoritmo de compresión que se llama rle Que obviamente no me lo he inventado yo sino que es un algoritmo de compresión muy viejo que lo que hace es agrupar los números que son iguales pero el problema esto es números no son iguales o sea el sistema tendría que detectar que este número va con este número y va con este número y va con este número pero no están seguidos Así que lo que voy a hacer es utilizar una técnica muy vieja 008 de agrupar los números y agrupar los números se hace de la siguiente forma vamos a ver Ah sin transparencia le voy a poner la siguiente información le voy a poner el rojo multiplicado por 255 * 255 más el verde multiplicado por 255 más el azul y si hacemos esto Claro ya no puede ser un u inay vamos a verlo ya no puede ser un u inay fijaos como al intentar hacer el u inay me lo machaca 232 imposible Vale y aquí está Perdona sin transparencia ahí vale os daris cuenta de que ahora tengo aquí 2 millones de elementos antes tenía ocho ahora tengo 2 millones y los elementos que están al principio son iguales son iguales porque ese color corresponde al color verde qué es lo que voy a hacer a continuación Pues voy a implementar un algoritmo rle para hacer que esta información sea más pequeña eso que quiere decir pues si saco in escape Mirad y hago un documento nuevo el problema que yo tenía el otro día era el siguiente el problema que yo tenía era que si tengo un ordenador que es el cliente y tengo un ordenador que es el servidor yo básicamente lo que estaba haciendo el otro día era Enviar un paquete de información gigantesco lo que hoy quiero es este paquete de información hacerlo lo más pequeño posible y que por tanto se envíe a más velocidad pero claro qué ocurre que para hacer esto aquí primero voy a tener que hacer una aplicación voy a tener que hacer un compresor tal que cuando el paquete entra sea grande y cuando el paquete sale sea pequeño de la misma forma de la misma forma de la misma forma más adelante voy a tener que programar un componente análogo vale esto Ahora ya está preparado para salir por la red voy a tener que programar un componente análogo tal que cuando el sistema reciba información y esa información esté comprimida el sistema sepa Cómo descomprimir esa información a la información real vale de momento ahora mismo estamos programando Este componente de aquí con la esperanza de que cuando enviamos estos paquetes al servidor pues quieras que no Por una parte la red sufra menos porque el tamaño del paquete es inferior y por otra parte el servidor sufra menos porque el tamaño del paquete que tiene que gestionar y que luego tiene que enviar es menor vale pero esto de aquí no va a salir gratis ese componente de compresión y descompresión cuesta proceso así que lo que estamos haciendo es aligerar la carga del ancho de banda de la red aligerar La carga del servidor a cambio de que el cliente tendrá que sufrir un poco más porque el cliente tiene que procesar y ahora veremos que no es un proceso pequeño precisamente el una gran pieza de información y comprimirla vale básicamente lo que se entiende por comprimir O sea que es básicamente hacer algo más pequeño pero a ser posible de las múltiples estrategias de compresión vamos a utilizar una estrategia de compresión sin pérdida porque no queremos que luego se pierda información vale aparte comprimir una captura de pantalla comprimir un pantallazo de un sistema operativo sin compresión es bastante agradecido vale una foto no un vídeo no pero comprimir un sistema es bastante mejor bien para ello lo que voy a hacer Vamos a ver ahora a parte de que ahora pondré eh comentarios es implementar un sistema de compresión como os decía antes llamado rle que como ya os digo no me he inventado yo sino que es no te digo más viejo que matar las cañas pero es bgt lo que hace el sistema de composión rle básicamente es agrupar números que sean similares agrupar números que sean correlativos vale primero vamos a comentar un poquito este código 009 y comentarios Vale entonces apuntamos al Lienzo creamos un contexto y anchura del Lienzo en este caso 1920 una captura de pantalla altura del Lienzo ahora creo una nueva imagen de javascript cargo apunto a una imagen real y cuando la imagen haya cargado en ese caso dibújame dibuja la imagen en el Lienzo y carga los datos en una array sin transparencia vale creo un array vacío creo un array vacío y para cada píxel descarto la transparencia y unifico ahora esto es memoria inicial esto es eh lo convierto no esto al final ahora mismo ya no me sirve porque ya no quiero una Ray de 8 bits ya no puedo entonces dentro de 100 milisegundos Mira la memoria final Haz una diferencia Sácame la diferencia y loguea vale saca array bien Ahora implementamos un 010 mecanismo de rle Hay un montón de funciones en internet preparadas js fun implement rle compression vale como digo es un método de compresión simple vale No es muy elaborado ahora veréis el aspecto que tiene de hecho y ya está Vale pues implemento este algoritmo lo pongo por aquí vale rlm Okay vale Si no hay cadena vacía esto no va a ocurrir te lo digo ya comprimido es igual a nada número es igual a uno contador Vale y vale si la cadena se repite aumenta el contador en caso contrario agrega un carácter Okay Venga pues vamos a ver qué aspecto tiene esto agrega el último carácter y vamos a por ello vale a continuación voy a decir que comprimido es igual a rle compression de sin transparencia y console pun log comprimido vamos a ver qué aspecto tiene esto porque yo ahora recargo me voy a rl y esto tiene vamos a verlo esto tiene este aspecto Ey Uh No este aspecto no debe tener e return no eh function to compress a Rise porque este me está comprimiendo cadenas pero yo quiero a Rise ahora esto ya es otra cosa Vale es lo mismo pero con arris y venga va compresa Ray el caso cuidado el caso vacío no lo quiero porque no le voy a pasar una array vacío quiero decir Me parece bien que chat gpt contemple ese caso pero como yo controlo la utilización pues sé que ese caso no se va a dar vale Y entonces recargo Vale ahora sí y démonos cuenta que he pasado a tener de 2 millones de piezas de información a 61000 piezas de información y si yo ahora a continuación veo los píxeles Mirad veo los píxeles y digo repite se repite se repite acordaos 6,49 pues yo me voy a ver qué tiene el rle y digo 6,49 704 se repite 9605 veces luego el píxel con identificador 1,7000 Tac atrás se repite 1910 veces Y eso quiere decir que ahora implementando este sencillo Porque conceptualmente es muy sencillo algoritmo de compresión en lugar de estar guardando los datos puros lo que estamos haciendo es guardar cadenas de datos es decir cadenas en las cuales eh estamos guardando las repeticiones de cada uno de los píxeles vamos a ver si podemos a ver si podemos sacar la información de memoria gastada antes y después a ver 011 info de memoria entonces para ello vamos a ver led memoria es utilizada vale Y yo digo comprimido es igual a esto a ver comprimido es igual a esto el console no lo quiero porque ya lo he visto el console ya no me hace falta Okay const final yo creo que ya vale vamos a verlo y aquí vale Y me dice aquí 2,678 a ver un momento memoria utilizada final no tú ah sí comprimido sí Okay comprimido vale Okay venga y ya está Vale pues Ahora a continuación lo que puedo hacer es enviar este información al servidor donde tal y como comentábamos ayer lo que estamos haciendo en este caso es realizar una compresión intra fotograma además Tenemos también la compresión inter fotograma para el sistema de videoconferencia Eso sí necesito como siempre estamos haciendo e encapsular esto de una forma que lo podamos reutilizar más fácilmente es decir este software es un software que funciona directamente pero yo necesito poder aplicarlo a algo Como por ejemplo lo que hacíamos ayer del Software de videoconferencia entonces para ello vamos a verlo el imagen on load ya no lo necesito 012 encapsular Vale y digo vamos a ver Okay Ok okay vale imagen onload no function comprimir el Fu comprimir Acepta una imagen y devuelve una colección que es la colección comprimida Si quieres voy a poner aquí colección comprimida y entonces digo esto es colección realmente Y entonces esto lo muevo aquí y digo en primer lugar primero quito la transparencia esto ya no lo quiero ahora cojo esto de aquí y le digo comprimido es igual a esto de aquí y return comprimido vale set Time out en este caso no va a hacer mucha falta Fuera vale Fuera voy a la bestia Fuera y por tanto a partir de este momento primero kilot transparencia luego comprimo rle Ok y ahora a continuación led comprimido es igual a comim de colección y eh console pun log de comprimido vamos a verlo encapsular cannot Access comprimido antes de que haya sido eh utilizado vale Bueno pues las funciones las puedo poner arriba y luego obviamente como podéis imaginar pues las funciones serán externalizadas en archivos externos vale recargo Ok comprimido before initialization Qué pasa Ah sí led comprimido vale o const comprimido Ok Vale ahora sí me da una array momentín espérate Ah no Claro vale Sí vale pues voy a hacerlo de vamos a ver pues voy a hacer esto imagen pun onload es igual a function y imagen vale Y ya está una vez que tenemos esto Una vez que hemos implementado un algoritmo de compresión insisto implementando una metodología rle como os podéis imaginar a continuación tenemos que implementar un algoritmo de descompresión es decir tenemos que implementar un algoritmo tal que cuando Recibe un paquete de datos comprimido lo extraiga lo expanda y lo descomprima Así que eso va a ser sencillo simplemente tenemos que hacer la operación inversa descomprimir vale vamos a ver por tanto en primer lugar cojo esto y me voy aquí y en la primera pieza create the compression función vale okay Y entonces ahora una vez que tengo Esto me voy a crear la función descomprimir la función comprimir y digo primero quito transparencia no primero No espera al revés aquí ahí primero descomprime descomprima rl descomprimido es rle dic compresa Ray de colección ahora pongo la transparencia o sea devuelvo la transparencia const con transparencia voy a decir Let y digo vamos a ver forlet colección Vale ahora tengo que intercalar ahora tengo que intercalar vamos a ver cómo lo podemos hacer voy a preguntar por aquí js given an array insert One Element each for elements Vale entonces realmente es cada tres fun insertar Okay voy a decir más igual a 3 a ver y es igual a 3 Ah no no no es el de antes es este es correcto vale es este bien entonces vengo por aquí y digo ahora descomprima con transparencia y digo con transparencia es igual a insertar en descomprimido inserto un 255 y devuelvo bueno led descomprimido y devuelvo descomprimido vamos a verlo si esto ha sido correcto porque diréis madre mía qu lío qué hemos hecho aquí o sea qué ha pasado aquí Vale pues Ahora digo Aquí console log array original console.log colección ahora console.log array comprimido console.log comprimido un momento que no lo puedo llamar antes de su declaración y ahora Ah mira ya lo tenía ahí vale Y ahora led descomprimido es igual a descomprimir eh comprimido o sea descomprimir lo que está comprimido y console punto log descomprimido si esto ha funcionado correctamente el resultado al final tendrá que ser exactamente igual al resultado al principio vamos a verlo descomprimir descomprimido has already been declared dónde Pues no lo sé descomprimido led descomprimido vale espera cons descomprimido Ok const claro eh o cost des rle vale No puedo repetir el identificador Okay venga bien pues vamos a verlo array original array comprimido e Qué pasa aquí Ah vale que está en ello Okay Uy madre mía lo que está tardando ahí pasa algo porque que tarda tanto es imposible algo está pasando Qué pasa rl compresa Ray voy a poner aquí decompression takes forever ah Espérate no aparte no no es que hay cosas que faltan rl decompress vale desde rle vale Y ahora aquí faltan cosas splice vale esto esto es correcto suir claro tengo que volver a convertir el número largo en componentes Esto es lo que me faltaba vamos a verlo Mira me lo ha devuelto pero estaba mal estaba mal vale Ok venga vamos a por ello recargamos Ahora sí bien y me da me dice Bueno algo pasa con Mary vale algo pasa con Mary porque me dice que el original ocupaba 800a 94,000 el comprimido ocupaba 61.000 pero el eh vamos a ver aquí pero el descomprimido son 27 millones no perdona 2,7 millones algo pasa a ver un segundo a ver un segundo Aquí voy a poner console pun log a raid descomprimido a ver un momento y vamos a echarle un vistazo a ver vengo por aquí vengo por aquí 98 146 24255 pero vengo por aquí 97 255 232 255 no está funcionando del todo bien vale Y aparte hay 2 millones de elementos algo no va del todo bien Entonces vamos a Por dónde está el error m de compression do not return original information vamos a ver no está recreando correctamente calcular el array eso sí que tiene buena pinta Vale y función descomprimir vamos a probarlo esto ya es otra cosa Vale esto ya es otra cosa en el sentido de que el arrayo original era de 8294 mientras que la Ray final es de 8 294000 creo que tengo un problema con los datos creo que tengo un problema con los datos Y es que los primeros datos son 98 146 24 255 mientras que los últimos datos Son 97 255 232 es decir 975 232 O sea curiosamente la información ha vuelto Pero ha vuelto poco corrupta vale Pero bueno no pasa nada porque simplemente es revisar qué es lo que ha hecho la descompresión rle y ajustarlo y ya está de hecho ahora mismo creo que me va a hacer gracia ver qué imagen resultante me da tiene pinta de que la imagen se va hacia azules mientras que esta imagen es más bien verde fijémonos que esta imagen se va más bien hacia azules vale con lo cual el error probablemente será mínimo en el código obviamente tenemos que arreglar el error Por supuesto que sí vale Pero a grandes rasgos A falta de afinar y a falta de ponerlo en funcionamiento y probarlo pero como podemos ver hemos implementado esta metodología de cojo algo te lo comprimo te lo envío comprimido eventualmente en un momento dado Hoy estamos ahora mismo estamos en local vale el servidor lo trabajará lo procesará y lo enviará me lo devuelve comprimido para que el servidor y la red sufran lo menos posible y te lo descomprima y te lo devuelvo a su estado original vale cosa Que obviamente para un sistema de videoconferencia Pues tendrá una utilidad enorme bien Sony 58 creo que tenéis clase Ahora de eh de eie vale con lo cual y luego de inglés así que me voy yo con los de primero y ahora luego volvemos y