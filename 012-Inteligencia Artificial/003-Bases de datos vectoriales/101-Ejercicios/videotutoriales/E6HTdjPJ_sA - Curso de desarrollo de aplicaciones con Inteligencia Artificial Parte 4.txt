bien a continuación para la siguiente parte vamos a aquí una nueva versión del ejercicio vamos a ejercicio 4 dejamos vamos a ejercicio 4 vamos a cerrar esto y así nos aseguramos que estamos trabajando con el ejercicio 4 nos soltamos aquí y ahora vamos a hacer lo siguiente en el ibex cuando vivos es igual a 1 en ese caso vamos a hacer lo siguiente bar el ganador como yo a ver cómo lo hemos llamado amador velocidad es igual a cero bar el ganador por qué el ganador radio es igual a cero estamos cogiendo los parámetros del ganador y cada momento es cero eibar pero las percepciones y rondón perfecto 1 bueno ahora vamos a hacer lo siguiente perceptor 1 es igual vamos a verlo a más puntos y menos 5 perfectos 2 es igual a lo mismo perceptor 3 es igual a lo mismo perceptor 4 es igual a lo mismo receptor 5 es igual a lo mismo de esta forma yo vengo aquí es un pero uno en tres puntos en 10.3 en 10.4 eres punto p 5 y esto lo que hace y esto lo que hace es que será el ganador yo cree que la de uno es igual a cero cuidado señala 0 el ganador de 2 es igual a cero p4 y p5 vale ahora function siguiente generación lo que va a hacer es lo siguiente de poner gana por velocidad gv grado radio agr y digo ganador velocidad es igual robots de y de vivo y punto velocidad el ganador radio es igual a radio ganador pero no es igual a 1 con esto lo que estoy haciendo es que la siguiente generación va a partir desde el ganador va a agregar el romero y así voy a repetir esto n veces a la siguiente generación ahora para cada uno de los robots voy a hacer una siguiente generación sosa es que lo que va a hacer es que todos van a agregar todo de él del grabador robots y energía es igual a 20 robots r es igual álvarez punto round vamos a verlo es lo mismo para ese paraje y para ver ahora importante es que robots bein de velocidad es igual a v robots de iu de radio es igual agr robots dp 1 es igual a gp 1 robots de iu de pedos es igual a la gp2 lo que estoy haciendo es que todos los robots que van a hacer en segunda generación van a ir directamente van a hacer aprendidos digamos van a heredar todos aquellos que han aprendido de la primera generación y yo creo que ya no se me olvida nada lo que podría hacer es que robots punto x es igual a más punto random por 500 y lo mismo para la lluvia o sea que reinicia en su posición yo creo que ya así que llamó a la siguiente generación y con esto ya estaríamos listos para trabajar ahora evidentemente lo que tenemos que hacer es esperar a que la generación llegue a uno para comprobar si es cierto que se reinician correctamente voy a grabar siguiente vídeo técnicamente lo que estamos haciendo es un poco de como si fuera diseño evolutivo es decir estamos haciendo voy a hacer una cosa 4 voy a hacer que la velocidad siempre tenga que ser un poquito velocidad más que nada por dos más que nada para que no haya muchos que estén parados y van cayendo y parece que caminan con mayor eficiencia vemos como ahora si están aprendiendo mejor ahora cuando quede uno vamos a comprobar si es cierto o no quedan 2 ahora se reinician y si nos fijamos ahora todos han heredado vemos como parece que se evitan mejor entre ellos vemos como todos tienen un patrón al final morirán alguna manera vemos como que están tardando más en morir después de unas cuantas generaciones vemos cómo van refrescando se iban refrescándose y al final vamos sacando un jugador y un ganador pero este juego tiene un pequeño problema ahora mismo y el pequeño problema es que realmente cada vez que saltamos de una generación a otra y al final tenemos el mismo la misma velocidad porque el ganador es exactamente igual al final es aburrido el ganador es mejor que la primera generación pero realmente no hay una mejora generación tras generación porque el ganador es el mejor pero no es de comillas perfecto si es que podríamos considerar que hay uno perfecto si podríamos tener el camino perfecto uno perfecto sería el que sobreviviera siempre así que a continuación lo que voy a hacer es ir cambiando de generación en generación intentando mejorar la generación y voy a hacer lo siguiente esto es igual a la velocidad es igual a más punto random 0.5 y esto lo voy a multiplicar por 0.2 es decir establezco una variación lo que hago es que no todos los de la siguiente generación sean exactamente iguales que el ganador sino que todos los de la siguiente generación son iguales que los llamados pero con alguna variación es decir lo que estoy haciendo básicamente para entendernos es una pequeña mutación lo que hago es indicarle al sistema que vamos a dar una variación más grande poner 0.25 más los de la siguiente generación están basados en el ganador de la generación anterior pero la idea es que haya ligeras variaciones que se puedan mejorar más todavía por cierto el con sol y ya no lo quiero y lo que quiero es qué la generación es igual a 1 cuando esto ocurre generación más con sol es punto el ojo estamos en la generación más generación muy bien vamos allá observamos algunos que van muriendo y la idea es que ahora cuando acabe esta generación la siguiente esté basada en la anterior vemos cómo estaban sobreviviendo tienen mejores competencias de navegación estamos en la generación 2 y ahora si los de la generación 2 se basan en la generación 1 pero con ligeras variaciones se basan en el ganador de la generación 1 pero con ligeras variaciones observamos como parece que tarden un poco más en morir guau generación 3 bien ocurre que muere en una forma muy uniforme se analizará generación 4 alguna cosa que puedo hacer por cierto es poner obstáculos habrán obstáculos y así yo creo que podremos esto tiene mejor pinta no han muerto todos curioso generación 6 cada vez me vieron mejor a generadores que no podemos ver si navega bien o mal porque en cuanto queda solo uno lo que voy a hacer es dejarle a ganador que nadie convocó él qué pasa ahora es curioso en la generación si tú todos han muerto creo que se den a del muerto dos a la vez y lo que voy a hacer es que voy a introducir en el código si vos es menor o igual que uno que creo que está muerto es la vez y me han fastidiado un poco el juego bueno antes de nada vamos a establecer unos cuantos obstáculos para establecer obstáculos voy a hacer es poner como una especie de zonas negras voy a crear la serie de cajas vale los obstáculos realmente podrían ser objetos entonces voy a crear un nuevo archivo lo voy a guardar esto está en ejercicio 2 pero realmente inteligencia artificial ejercicio 4 y se va a llamar obstáculos punto j s los capítulos se ha llamado entonces cojo el código de robot pero en obstáculos y esto va a ser mucho más sencillo y ya está los obstáculos no se mueven así que w es igual además punto random por 50 w es el wish es la anchura el sol heights es la altura y entonces dibuja es contexto punto fil recta y voy a decir x y anchura como altura por cierto por si alguna duda contexto punto feel style es igual a black esto es clase obstáculo y ahora lo que hago es que en el index y digo temple pantalla rejilla y luego lo siguiente número obstáculos es igual a 10 por ejemplo dijo ford j es igual a 0 j es menor que número obstáculos j + + y voy a hacer para empezar más obstáculos es igual ánimo a wright y entonces j obstáculos de hellín es igual a mi obstáculo se llama obstáculo y ya está entonces ahora vengo por aquí obstáculos j punto dibujaron y yo creo que yo el obstáculo y sin antifaz vale en la línea 39 y obstáculo porque de la misma forma he incluido robots tengo clic que incluir obstáculos dibuja el fandi find me vamos allá los obstáculos a js es un obstáculo los abuelos de j x snow design en obstáculos dibujo y eso tiene pinta de ser porque no es x sino de punto x es la propiedad de este mismo objeto y no es una propiedad de externo muy bien tengo una serie de obstáculos vemos como los obstáculos hacen que los objetos colisionan y pierda energía con lo cual lo que puedo hacer ahora es lo siguiente lo que puedo hacer es en index decirle que quiero menos robots pero quiero más obstáculos y de esa forma así lo que hago es intentar asegurar que los robots tengan el camino más despejado para poder navegar cuando tengo un ganador luego quiero disfrutar un poquito de será mejor entonces porque cuando tengo un ganador pero lo que ocurre es que automáticamente salto a la siguiente ronda pero tampoco está mal y ahora a ver los ganadores es interesante ver como los objetos aprenden bastante bien al final a caminar sin colisiones y bueno lo que voy a hacer a continuación es dejar que el ganador vio a un poquito más yo cuando tenga un ganador de ronda que voy a disfrutar un poquito y quiero ver quiero ponerlo a prueba a ver si realmente vive o muere ok la verdad es que no me puedo quedar sin la verdad donde me puedo quedar bloqueado dejarlo así vamos a ver sí finalmente claro quiero esperar a que el ganador muera entonces ok es menor o igual que 0 esto quiere decir que voy a esperar a que incluso el ganador muera vemos como el color rojo tiene bastantes papeletas y esperamos a que muera y se mueve hereda o se otorga a la siguiente generación de información y si todo va bien la siguiente generación deberían ir mejor igual no lo sé es decir lo que estamos haciendo es un programa para comprobar si es cierto o no que el individuo mejor preparado es el que evoluciona es el que pasa a la siguiente generación podría ser que recuperarán vida con un poquito más de facilidad porque también es cierto que creo que mueren enseguida para hacer que recuperen villano y por tanto de esta forma estamos premiando los que sobreviven vale de esta forma tenemos uno vamos a la siguiente generación eventualmente lo esperable entre comillas podría ser que llegáramos a un momento en el que no hubiera no murieron digamos hoy también y poder modificar la velocidad pero llegado más uno para ir más lento si quieren por tres más uno se mueven los rápidos se mueven los lentos hay algunos que están en bucle para efe y con esto en este ejercicio hemos conseguido por lo menos empezar a demostrar la aplicación de una más en el er ning es decir hemos aplicado varias cosas todavía no tenemos redes neuronales a continuación haremos pero tenemos ya la capacidad de hacer un programa que realiza múltiples variaciones y una vez que ha hecho estas variaciones lo que hace es ponerlas a prueba y una vez que las ha puesto a prueba pues es capaz de obtener la mejor variación sea un ejemplo de diseño generativo y una vez que tiene la mejor variación lo que hace es pasarla a la siguiente generación bueno con esto tenemos una serie de variaciones una serie de hechos que realmente no colisionan con lo cual es el objetivo si los dejo un buen rato al final yo creo que habrá un ganador de una forma u otra realmente acaban yendo en bucle vamos a hacer que pierdan un poquito más de vida estoy buscando es el equilibrio de parámetros hasta encontrar realmente una evolución voy a retocar más la vida tenemos el ganador de la primera ronda y ahora bueno si era grado primera ronda por lo que sea nueve pues ya pasamos a la segunda ronda y quiero ver que realmente en la segunda ronda los elementos realmente aprendan de este ganador si es que llega a morir sería divertido comprobar que vivirá eternamente porque eso demostraría que desde cierto punto de vista sería perfecto podía ser de 100 x no se muere pues paso a la siguiente ronda de todas formas pero bueno es curioso ver y al final pues sobrevivir acaba sobreviviendo y me da a mí que está entrando en bucle espacioso puedo reiniciar la simulación para ver si consigo que más clara porque si no muere es divertido porque es suficientemente perfecto pero no es divertido porque quiero ver qué pasa en la siguiente generación qué se queda esta mentira - que parece que quiere que muera pero ay vale venga siguiente generación y ahora si todavía en la siguiente generación serán algo más inteligente vaya qué rápida muerto ya se ve dejarlo funcionando unas cuantas generaciones hasta ver quién gana después de una serie de pruebas bueno básicamente tenemos esto tenemos que llevo un rato en la generación 23 hay veces que cuando es realizado esta prueba ha llegado hasta la 30 33 35 más o menos ahí se para bueno digo que se para quiero decir que llega un momento en el que el sistema es lo suficientemente experto como para poder sobrevivir digamos eternamente le he dicho de esto dicho esto voy a hacer lo siguiente voy a introducir un poquito de vamos a hablar un poquito m quito de variación vamos a cambiar un poquito la dirección progresivamente y sobre todo quiero saber quiero comprobar que realmente se produce una mejora quiero saber vamos a ver dar tiempos igual a cero quiero saber cuánto tiempo dura cada interacción así que tiempo más por aquí a continuación digo estamos en la generación tal y el tiempo es a tiempo y cuando ocurre esto digo qué tiempo es igual a 0 de esta forma al introducir está variación lo que estoy haciendo vamos a ver cuánto tarda la primera generación lo que estoy haciendo es afiliar el sistema al cuidado en la variación de la dirección la voy a hacer solo en el caso de que vamos a ver pues la variación vamos a hacerla solo en el caso de que la energía sea 1 voy a multiplicar esto por 0.2 vamos a verse así el objetivo es que los distritos no vayan tan recto sino que tengan un poquito de variación de velocidad ya tenemos allí que se va a acabar la primera generación el primer mito que no sobreviva en el tiempo es mil 533 mil 833 son los ciclos que han sobrevivido en este objeto 327 curiosamente la generación ahora 268 curiosamente deberían vivir más vamos a comprobarlo 796 teóricamente lo que debería ocurrir es que cada generación debería vivir más de hecho hasta introducir esta variación esto lo voy a quitar un momento realmente era así introducir esa variación es cuando parece que han vivido menos vamos a quitar esa variación a continuación sobreviva o no nuestra simulación y básicamente lo que estamos haciendo ahora es consiste en medir nos 27 en comprobar que hay una mejora no sólo pasar generaciones sino comprobar si realmente es cierto que cada generación aprende de la anterior y eso hace que sobrellevan más es decir que hay una evolución pero esto por tanto finalmente como digo la máquina está aprendiendo lo que hace es pasar lo que ha aprendido la siguiente generación e intentar que la siguiente generación sobreviva más y mejor viene claramente esta generación yo diría que va a durar más que la anterior y eso que el terreno de juego que se ha quedado no es particularmente sencillo cuidado por qué y se nos han quedado 4 no sabemos cuánto van a sobrevivir pero en principio están en bucle y en bucle se pueden tirar bastante rato lo cual no es malo porque quiere decir que son diseños que funcionan pero me gustaría ver un poco de progreso generación a generación cuando digo que me gustaría si hay que tener en cuenta como he comentado anteriormente varias veces que en inteligencia artificial la gracia no es que salga lo que yo quiero que salga sino a veces muchas veces la gracia es que precisamente pues lleguen a salir cosas que yo no esperaba que salieran voy a recargar y el objetivo como digo es comprobar parece curioso ahora que si bien en pruebas anteriores las primeras generaciones cambiaban bastante rápido vamos a ponerle un poco difícil en número de robots siempre sé cuándo los obligarán a interactuar más vale ya tenemos un ganador breves muere pasaremos la siguiente fase fijémonos que la velocidad nuestra aleatoria porque la velocidad viene heredada alargador curioso 32 56 vamos a ver qué pasa curioso vamos a dejarlos progresar y ahora en un momento volveré para revisar qué es lo que ha ocurrido hasta este nivel es difícil nos fijamos bueno está empecemos bar círculos para evitarse entre ellos ahora si poco a poco están empezando para celebrar más voy a dejar estoy rodando y ahora a continuación analizamos el resultado es curioso que en una de las pruebas que estoy haciendo los bichitos se hacen con una especie de vibración que más o menos les funciona bien pero hay que tener en cuenta que esa liberación deriva del ganador de la anterior edición eso quiere decir que si el ganador de la anterior generación tiene una serie de características por muy extrañas que parezcan esas características pasan a la siguiente generación lo cual pues puede resultar curioso pero realmente no importa si es curioso o no lo único que importa es si funciona o no y esto es una vez más lo que tiene en este caso más en el jardín y es que la máquina puede llegar a conclusiones que igual nosotros como seres humanos no se hubieran o nos hubiera ocurrido llegar bueno pues en este caso esta generación he puesto un límite de 4000 siempre es el tiempo llegar a 4000 la aceleración debe continuar pues en este caso en esta prueba concreta los bichos están haciendo una vibración que no esperaba y también tener un ajuste un poco extraño de las extremidades pero y de los sensores pero el caso es que les funciona el caso que se nos podemos fijar pues van sobreviviendo se van llevando entre ellos qué bueno y aprenden a evitarse aprenden a coexistir y aprender en definitiva pues a moverse interesante una vez más es que mediante esta aplicación yo no le he enseñado a la máquina cómo tiene que caminar ella generación a la generación ha aprendido sola y ha llegado a la conclusión otra vez cuatro mil ya llega a la conclusión de que esta es la mejor combinación para poder sobrevivir y le está haciendo de hecho ya llevamos dos generaciones de 4000 y en principio parece que el programa ha encontrado un balance entre velocidad y ángulos de sensor y giros balance extraño pero un balance al señala cabo vivo extraño con respecto a lo que yo podría esperar pero si el programa ha encontrado esto y le funciona pues es que es válido vamos a recargar de nuevo probablemente recargando el programa llegará a otra solución diferente lo interesante es que finalmente llega a una solución vamos a dejar esto funcionando un rato voy a hacer una variación mientras lo dejo corriendo y hacer como gráfica aquí en la consola va a ser muy curioso y puede hacerlo siempre cadena es igual entonces es igual a cero es menor tiempo partido 100 y esto es más punto round punto y coma temas más y entonces cadena más igual a equis y aquí voy a poner lo que quiero es que en la consola en lugar de aparecer un número aparezcan unas equis se conocen con una especie de barra vamos a verlo tengo ayunas x y lo que quiero básicamente con las x digamos el sistema era como una especie de gráfico de barras es más vemos como las x bueno hacer una especie de gráfico de barras para poder saber cuándo dura más y cuando dura menos y así poder saber si estaba mejor o no va mejor voy a hacer una cosa vamos a eliminar verborrea y ahora voy a dejar esto funcionando un rato ya partir de ahí podremos obtener la conclusión del ejercicio básicamente voy adelantando que la conclusión del ejercicio parece cero muchas veces la primera generación el que sobrevive curiosamente esto que voy a decir es curioso pero el que el sonido curiosamente no es el mejor preparado si nos recibe el que sobrevive de casualidad pero luego en las siguientes generaciones es cuando inevitablemente tienen que producirse mejoras en ese desarrollo debido para que la supervivencia sea mayor generalmente pero teóricamente se van produciendo mejoras todas formas vamos a dejar esto encendido unas cuantas veces vamos a dejar que correr unas cuantas generaciones y así finalmente podremos comprobar si esta certeza es correcta o no lo es bueno después de unas cuantas generaciones por ejemplo en este caso hemos llegado a un ejemplo donde en la generación 14 pues prácticamente mueren dos pero el resto han llegado a un punto digamos de equilibrio donde pueden vivir y pueden convivir y no pegarse entre sí es decir llegan a un punto de equilibrio en el cual saben cómo navegar para no chocarse y bueno ya han aprendido digamos a sobrevivir en este caso llegan al límite de 4000 y fijémonos que hace prácticamente tres generaciones que han llegado a ese equilibrio ahora simplemente pues algunas tienen la materia de color amarillo y bueno pues como podemos comprobar sí que mayormente es probable que a lo largo de las generaciones en este caso en esta prueba concreta han llegado en la generación 12 es posible que en otras pruebas puedan llegar más tarde porque es lo bueno que tiene yo no espero que lleguen en la generación 12 yo simplemente pulso play y no sé lo que va a ocurrir porque lo que están haciendo es evolucionar y dado que en el momento en el que evolucionan pues hay un cierto factor aleatorio un cierto factor literalmente random porque es literalmente introducimos un random en el código pues no sé realmente lo que va a ocurrir lo que estamos viendo por tanto es que me lo tenemos en la pantalla pues estos elementos y gracias a esto finalmente podríamos obtener un resultado de cuáles son los balances para los sensores y qué ángulos deben tomar los objetos para no colisionar entre ellos o no colisionar con paredes o lo que sea y luego evidentemente podríamos utilizar esta información para múltiples ámbitos para robots de limpieza para videojuegos para robots de vigilancia o en definitiva para el uso que le queramos dar siempre que evidentemente el robot donde lo queramos aplicar tenga una serie de sensores de características similares a los que hemos utilizado la idea el mensaje evidentemente es que yo no he tenido como ser humano que programar cuál es el comportamiento que deben tener esos sensores y cómo debe reaccionar el objeto de sus sensores sino que ha sido la múltiple prueba y error lo que ha hecho llegar al programa por sí mismo a una conclusión óptima