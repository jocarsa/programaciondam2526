vale los obstáculos realmente podrían ser objetos entonces voy a crear un nuevo archivo lo voy a guardar esto está en ejercicio 2 pero realmente inteligencia artificial ejercicio 4 y se va a llamar obstáculos punto j s los capítulos se llamaron entonces cojo el código de robot pero en obstáculos y esto va a ser mucho más sencillo no se mueven asiste w es igual jamás punto random por 50 w es el wifi es la anchura del sel heights es la altura y entonces dibuja es contexto punto fil recto y x y anchura como la altura por cierto por si alguna duda contexto punto feel style es igual a black esto es clase obstáculo y ahora lo que hago es que en el index y digo limpia pantalla rejilla y digo lo siguiente número obstáculos es igual a 10 por ejemplo dijo ford j es igual a 0 j es menor que número obstáculos j + + y voy a hacer para empezar más obstáculos es igual a mí oa right y entonces j obstáculos de allí es igual a mi obstáculo se llama obstáculo y ya está entonces ahora vengo por aquí obstáculos j punto en dibujar y yo creo que yo el obstáculo y sin antifaz vale en la línea 39 y obstáculo porque de la misma forma que he incluido robots tengo clic e incluir obstáculos dibuja el fandi find me vamos allá los obstáculos a js es un new obstáculo los cálculos de j x snow design en obstáculos dibujo y eso tiene pinta de ser porque no es x sino de x es la propiedad de este mismo objeto y no es no trata de estar muy bien tengo una serie de obstáculos vemos como los obstáculos hacen que los objetos colisionan y pierda la energía con lo cual lo que puedo hacer ahora es lo siguiente lo que puedo hacer es en index decirle que quiero menos robots pero quiero más obstáculos y de esa forma así lo que hago es intentar asegurar que los robots tengan el camino más despejado para poder navegar cuando tengo un ganador luego quiero disfrutar un poquito de ese ganador entonces y cuando tengo un ganador lo que ocurre es que automáticamente salto a la siguiente ronda pero tampoco está mal era a ver los ganadores es interesante ver como los objetos aprenden bastante bien al final a caminar sin colisiones y bueno lo que voy a hacer a continuación es dejar que el ganador viva un poquito más yo cuando tenga un ganador de ronda quiero disfrutar un poquito y quiero ver quiero ponerlo a prueba ya ver si realmente vive o muere ok pero es que no me puedo quedar sin donde puedo ver lo creado a dejarlo así vamos a ver sí finalmente claro quiero esperar a que el ganador muera entonces es menor o igual que 0 esto quiere decir que voy a esperar a que incluso el ganador muera el color rojo tiene bastantes papeletas esperamos a que muera y se mueve hereda se otorga a la siguiente generación la información y si todo va bien la siguiente generación deberían ir mejor igual no lo sé es decir lo que estamos haciendo es un programa para comprobar si es cierto o no que el individuo mejor preparado es el que evoluciona es el que pasa a la siguiente generación podría ser que recuperaran mira con un poquito más de facilidad porque también es cierto que creo que mueren enseguida hacer que recupere un villano y por tanto de esta forma estamos premiando los que sobreviven vale de esta forma tenemos uno vamos a la siguiente generación eventualmente lo esperable entre comillas podría ser que llegáramos a un momento en el que hubiera no murieron digamos hoy también a y poder modificar la velocidad drogado más uno para ir más lento si quieren por 31 se mueven los rápidos se mueven los lentos en algunos que están en bucle para efe y con esto en este ejercicio hemos conseguido por lo menos empezar a demostrar la aplicación de una minga es decir hemos aplicado varias cosas todavía no tenemos redes neuronales a continuación haremos pero tenemos ya la capacidad de hacer un programa que realiza múltiples variaciones y una vez que ha hecho estas variaciones lo que hace es ponerlas a prueba y una vez que las ha puesto a prueba pues es capaz de obtener la mejor variación sería un ejemplo de diseño generativo y una vez que tiene la mejor variación lo que hace es pasarla a la siguiente generación bueno con esto tenemos una serie de variaciones una serie de dichos que realmente no colisionan con lo cual es el objetivo si los dejo un buen rato al final yo creo que habrá un ganador de una forma u otra realmente acaban yendo en bucle vamos a hacer que pierdan un poquito más de vida estoy buscando es el equilibrio de parámetros hasta encontrar realmente una evolución voy a retocar más la vino tenemos el ganador de la primera ronda y ahora bueno si era graduado primera ronda por lo que sea 9 pues ya pasamos a la segunda ronda y quiero ver que realmente en la segunda ronda los elementos realmente aprendan de este ganador si es que llega a morir sería divertido comprobar que viviera eternamente porque eso demostraría que desde cierto punto de vista sería perfecto podría ser un time out 100 x no se muere pues paso a la siguiente ronda de transformas pero bueno es curioso ver al final pues sobrevivir casi pero acaba sobreviviendo y me da a mí que está entrando en bucle es precioso puedo reiniciar la simulación para ver si consigo que más que nada porque si no muere es divertido porque es suficientemente perfecto pero no es divertido porque quiero ver qué pasa en la siguiente generación qué se queda la mentira de los que parece que quiere que muera pero ay vale venga siguiente generación y ahora si todavía en la siguiente generación que serán algo más inteligente ese es el de hoy vaya rápido ha muerto y así voy a dejarlo funcionando unas cuantas generaciones hasta ver quién gana