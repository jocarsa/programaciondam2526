Eh, la clase de hoy yo creo que va a ser muy intensa, pero yo creo que ello no es motivo para preocuparse. Y a continuación os voy a comentar, os voy a explicar el por qué. Bien, con los lenguajes que nosotros hemos aprendido hasta el momento, yo creo que tenéis para hacer un poco de todo, ¿vale? Entonces, por ejemplo, en el terreno web habéis aprendido HTML, CSS y JavaScript, ¿vale? Que son los lenguajes estándar, es decir, en el terreno web cliente, espérate que saque el chat, ¿vale? En el terreno web cliente no hay otros, son estos los que hay que aprender, no hay más alternativa. Luego tenemos el terreno eh servidor. En el terreno servidor tenemos PHP, tenemos node JS, que viene a ser JavaScript y tenemos Python. Con lo cual, pues hay varios lenguajes que podemos abarcar, pero hemos aprendido los tres que a día de hoy se consideran los más estándar. Esto en cuanto a servidor desde el punto de vista de servidor web, es decir, lenguajes de programación del servidor. Luego tenemos que hemos aprendido también a desarrollar aplicaciones de servidor, por ejemplo, temas de copias de seguridad, etcétera. Y para ello hemos aprendido Python, el mismo Python que gracias a Flask nos ha servido para crear servidores web, pues también sin flask nos sirve para crear aplicaciones de servidor, aplicaciones que en un momento dado podemos utilizar con Chrome y todo eso. Bien, y también en el caso de crear aplicaciones de escritorio, o bien en consola o bien en con interfaz gráfica de usuario basada en ventanas, pues igualmente hemos aprendido Python. En el caso de interfaz eh con ventanas, pues también hemos visto los fundamentos de TK Inter. Eso quiere decir, insisto, que la ensalada, el cóctel de tecnologías, que ayer un poco preguntaba Luis, ¿vale? Es este que hemos visto, este que tenemos en la pantalla y es el cóctel que este curso es seleccionado para vosotros. Cuando digo este curso, quiero decir que cada curso repaso el software y repaso el cóctel para asegurarme que quito aquello que se vaya quedando desfasado y pongo aquello que empiece a ser relevante y que tenga pinta de que va a seguir siendo relevante a lo largo del tiempo. Este cóctel, evidentemente, está basado en ese criterio y no en el criterio de enseñároslo todo, porque todo cabe. ¿Vale? Por ejemplo, en más de una ocasión os he dicho que muy a mi pesar, pues este curso, a diferencia de cursos anteriores, pues he tenido que quitar Java porque Java, desgraciadamente es un lenguaje que se está quedando fuera, ¿vale? Que está cayendo. Ya sabéis que siempre esta no es mi voluntad, ¿vale? Para mí, Java es un lenguaje que a nivel didáctico, a nivel docente, siempre me ha venido muy bien, pero ya sabéis que Java pues es esto, ¿vale? Java es un lenguaje que pues está aquí, es decir, en un momento dado, digamos, 2002, pues ocupó más de un cuarto, ¿vale? Uno de cada cuatro trabajos era para Java, pero a día de hoy, pues como veis, no es ya que ha caído a un 10%. hemos pasado de uno cada cuatro a uno cada 10, sino que sobre todo es que sigue cayendo y no hay decisiones por parte de Oracle, al menos perceptibles, que me hagan pensar que esto va a cambiar o incluso se va a revertir. Creedme que lo querría, pero no lo estoy viendo, al menos de momento. Si nos vamos atrás al índice TV, veréis que pues si hago tanta tanto hincapié en Python, pues es precisamente por eso, porque no es solo que está aquí arriba en el primer lugar, es que el cambio interanual es del 8%. Si os fijáis, si comparáis con el resto de lenguajes, el 8% es una salvajada. Si hago clic en la gráfica de Python, Python está disparado, ¿vale? Y al igual que os decía hace un momento en Java y no parece que la cosa vaya a cambiar. Es decir, Python no, al parecer no es que esté sufriendo el hype del momento, que hoy está de moda y mañana no lo está, sino que Python es un lenguaje que al final te resuelve problemas y por tanto, o sea, y te resuelve problemas a ti y a un montón de gente. Por tanto, pues todo parece indicar que esta gráfica pujante que estáis viendo, pues no es una tendencia que podamos asociar a una moda, sino que es una tendencia que va a tener una durabilidad para siempre, pues probablemente no. Vale, ¿qué pasará dentro de 10 años? No lo sé, pero ¿qué pasará dentro de un año? Pues sí que parece que esta gráfica nos lo viene a decir. ¿Vale? Bien. Eh, esta gráfica es un poco curiosa porque si os dais cuenta, los lenguajes y eh derivados de C, es decir, el lenguaje C y los derivados de C, que son C++, que es C objetos, y C#ARP, que es el C orientado a objetos de Microsoft. Claro, están por separado, pero si os fijáis 11%, 9% y 4,8% pues prácticamente suman 25%. Es decir, si os dais cuenta, pues la suma de los tres CS casi es como Python y C++ el solo tiene el 11% de la cuota, con lo cual actualmente está en segundo lugar con una subida interanual. del tercer lugar al segundo lugar. Si hacemos clic en C++ es curioso porque un lenguaje relativamente antiguo para lo que entendemos que es la historia de la informática, derivado a su vez de C, extiende a C, pero sin embargo, pues este es uno de esos lenguajes que pues oye, igual me lo decís hace 10 años y hace 10 años yo os diría, "Espérate, que parece que fe poquito a poquito va hacia abajo como Java. hoy, pero sin embargo, pues por las claro en el momento en el que cae Java, en ciertos aspectos necesitamos un lenguaje que reemplace a Java y uno de los lenguajes que viene a reemplazar a Java es C++. Es curioso porque precisamente Java vino a reemplazar a C++, ¿vale? Y insisto, y Java no solo es un buen reemplazo, Java es un excelente reemplazo para C+ más, pero Java es propiedad de Oracle y Oracle a lo largo de esta última década ha maltratado sistemáticamente no solo a Java, sino a los usuarios de Java, mientras que C++ es abierto. Nadie puede controlar C++ al igual que otros lenguajes que son abiertos. Por tanto, la gente lo que está haciendo es volver hace más, ¿vale? Aunque insisto, la arquitectura interna, las librerías, la modernidad, entre comillas, ¿vale? Modernidad relativa de Java es muy conveniente con respecto a C++, pero yo en consciencia no os puedo enseñar Java, ¿vale? Sí, sí, sí. Vamos a hablar un poco de ello antes de meternos con C+ Má. Go es un lenguaje propietario de Google y esto genera tanto amor como odio. Es decir, eh, Go, en mi caso, me genera rechazo, no porque sea de Google, me da igual que sea de Google, que sea de Microsoft, que sea de quien sea, me genera rechazo un lenguaje de programación que es parte de una empresa privada, que es propiedad exclusiva de una empresa privada y que esa empresa privada hoy hace una cosa y mañana hace otra diferente. ¿Vale? Por tanto, claro, hay mucha gente que dice Google es lo más, luego, por tanto, el lenguaje Go es lo más. Bien, no te digo que no. Yo no digo que Google no sea lo más. De hecho, desde el punto de vista ético, hay pocas cosas reprochables a Google. Quiero decir, el comportamiento de Google hasta el momento ha sido un comportamiento bastante constante, bastante previsible y bastante ético. Quiero decir con esto que me puedo fiar más de Google que de otras muchas empresas, pero sigue siendo una empresa privada, con lo cual yo a lo largo de los años las lecciones que he aprendido en mis carnes pues me hacen desconfiar de aquellos lenguajes que son propiedad de una empresa privada. Ahora, Rust últimamente ha tenido bastante repercusión. Os voy a decir una cosa ahora luego buscarla porque Rast es muy parecido a C++ pero tiene un uso más responsable de la memoria. Es decir, con C++ tú te ocupas de gestionar la memoria y si no gestionas correctamente la memoria, como hoy vamos a ver, te puedes cargar la máquina, es decir, puedes hacer que se reinicie el sistema operativo. ¿Vale? A ver, claro, pero vamos a entender esto que estás comentando. Es decir, eh Google en un momento dado saca Angular y efectivamente, tal y como acabas de decir, eh, no es que luego no use, ¿vale? Sino que Angular es un framework. Entonces Google en un momento dado, hace unos años, hace 10 años por ahí, 2014, quiero recordar, saca Angular y vamos a ver, voy a poner Angular y Google dice, "Oye, eh, usad esto, esto mola." ¿Vale? Y la gente lo empieza a usar y realmente mola. Es cierto que Angular mola, pero el problema está, ¿vale?, en que Angular, pues mira, 2013 tiene un periodo de subida, tiene un periodo de subida, pero como siempre os digo de los frameworks, a partir de ahí tiene un periodo de bajada. Ahora mismo estamos en bajada. ¿Por qué? Pues porque el problema que tienen los frameworks es que son muy sujetos a modas. Por eso intento evitar enseñaros frameworks, porque de repente aparece otro motor, otro framework llamado React y de repente ocurre esto. Y es que ahí donde Angular empieza a caer, React empieza a subir. Pero es que a React dentro de 5 años le pasará lo mismo y es que React dejará de estar de moda y vendrá otro framework que vendrá a reemplazar a React. Claro, esto es para criticar a Google desde mi punto de vista, ¿no? Es decir, yo le tengo agradecimiento a Google por en su momento sacar Angular, de la misma forma que ahora le tengo agradecimiento a Facebook por sacar React, en el sentido de que a mí Angular no me hace especial gracia en cuanto a que además lo van cambiando muy rápidamente y lo que hago es en Angular en un año ya no te sirve año siguiente. Pero a mí personalmente Angular me ha ayudado en ciertos momentos y para ciertas cosas a implantar buenas prácticas en el desarrollo. De hecho, en el proyecto All, el desarrollo en base a componentes os lo he enseñado y yo fundamentalmente lo aprendí en su momento gracias a Angular y por eso le estoy agradecido a Angular. Ahora, ¿qué ha pasado de moda? Pues bueno, pero es que eso no es problema de Google, es que todos los frameworks pasan de moda. Claro, da desconfianza, ¿sí? No, es decir, a mí eso me da desconfianza de los frameworks, no de Google, porque insisto, tú buscas, por ejemplo, el framework G, ¿vale? J Software o el framework Yui, el de Yahoo Yui framework work. A ver, vamos a ver si aparece por aquí. Y no, por ahí aparece muy machacado. Un momentín, ¿vale? O Bue, que también ahora está de moda, el Bue JS. Ahí, pues al final todos los frameworks pasan de moda al fin y al cabo. Claro, echarle la culpa a Google pues yo creo que no es lo correcto. Google pues mira, en su momento saca un framework y nos lo da gratuitamente. Oye, pues gracias, ¿sabes? Igual que gracias a React y gracias a tal. Claro, ahí probablemente Hola, muy buenas. ¿Qué hay? Buenas. cualquier cos, ¿eh? Vale, pero ¿quién eres? El profesor. Okay, vale. No te conocía. Paso, pasa, siéntate. Entonces, como os digo, pues el yo creo que ahí la culpa no es hacia Google, sino eh hacia todas aquellas personas que en su momento Google te saca un framework como Angular y piensan que Angular va a ser para siempre. Bueno, lo cierto es que si miramos la historia de los frameworks, veremos que la duración de cada uno son 10 años, que es básicamente la duración que tiene Angular. Y no es que esté muerto, simplemente está en caída, como podemos ver en la gráfica de Google Trends, tardará unos cuantos años en caer todavía, ¿vale? Al igual que React ahora está en su vida y ya veremos qué es lo que ocurre con React a 5 o 10 años vista, ¿vale? Y luego, volviendo al tema de Rust, eh últimamente está de moda, digamos, por lo que os comentaba antes, por el tema de la protección de la memoria, porque así como con C++, que ahora vamos con ello, eh, en un momento dado, si no tienes cuidado y si no vas liberando la memoria periódicamente la que utilizas, pues como os digo, puedes llegar a colgar el ordenador si vas acumulando y no liberas. Mientras que Rust tiene una serie de funciones que te permiten, digamos, tener el control de C++, pero herramientas de acceso más seguro a la memoria. Claro, es como lo de Angular, ¿de quién es la culpa? La culpa es del lenguaje de programación o la culpa es del programador que se olvida de liberar los recursos que ha abierto. Pues claro. Entonces ahora hay mucha controversia en internet acerca de que parece que quieren imponer Rust para reescribir un montón de partes del código de sistemas operativos tales como, por ejemplo, Linux. Y te digo Linux más que nada porque es un sistema operativo abierto del cual pues tenemos información abierta y libre de cuáles son los planes para las siguientes versiones del kernel. En el caso de ecosistemas como el de Microsoft, primero entendemos que no estarán usando Rust porque estarán usando sus propias tecnologías y segundo, evidentemente la información sobre el desarrollo de kernels cerrados, como insisto el de Microsoft, pues obviamente no es tan pública. ¿Vale? ¿Qué pasará con RAS? Pues no lo sé. Vale, es decir, si miramos en el índice Tube, veremos que es un lenguaje que está pujando momento aquí. Vale, veremos que es un lenguaje que está pujando. Claro, actualmente está en el puesto 14. Quiero decir que yo actualmente no lo considero una prioridad desde el punto de vista del programa formativo. Hay que reconocer que en la variación interanual ha subido tres puestos enteros. Ha pasado del 17 en marzo del año pasado al 14 a día de hoy. Y si hacemos clic y entramos en Rust, pues veremos que claro, la subida parece muy fuerte. Daos cuenta en la escala en abscisas que estamos pasando de un cer en 2011 a un 1,23% en el día de hoy. Parece una subida impresionante, pero si os fijáis en la escala de la gráfica, pues bueno, vale, está subiendo, ¿vale? Y como está subiendo, ya os digo, yo lo tengo muy en el radar para irlo viendo cada pocos meses, irle realizando el seguimiento y si en un momento dado, pues lo que os comentaba al principio de la clase, Rust se pone de moda y obviamente lo que a mí me interesa para vosotros en las empresas de trabajo empiezan a pedir Rust, pues evidentemente aquí en el ciclo enseñaré RAST por el mismo criterio que os decía antes con respecto al resto de lenguajes, incluido Java, ¿vale? Pero eso es lo que te comento, pero más allá de ello es un lenguaje de es un lenguaje de programación como otros muchos. Luego en cuanto al tema de la gestión de la memoria, pues ya os digo, lo que os he comentado de Rust, insisto, no es una crítica hacia Rust, es una crítica hacia los programadores, digamos, como te diría yo, entre comillas, vagos, ¿vale? O poco cuidadosos. Claro que lo mismo podríamos decir de Python en el sentido de que eh muchas veces hemos comentado que uno de los grandes factores que explican el triunfo a día de hoy, marzo 2025 de Python, es precisamente no tener que ocuparte de un montón de cosas a bajo nivel, por ejemplo, en cuanto a gestión de la memoria, ni se tipifican datos de forma nativa, que luego puedes forzar el tipo, como vimos en su momento en el primer trimestre, pues sí, pero de entrada tú dices edades es igual a 47 y Python dice, pues fantástico, pues internamente ya te lo convierto yo en un entero, en un float o en lo que sea que te lo tenga que convertir, ¿vale? Y eso vemos que nos da a nosotros y a muchas más a mucha más gente ventajas, pero sin embargo también en clase hemos sufrido pues qué es lo que ocurre cuando el intérprete infiere el tipo de dato y a veces pues esa inferencia que ha hecho no nos conviene y tenemos que forzar manualmente el cambio de tipo. En cuyo caso pues hay veces que entre comillas todo lo que habíamos avanzado al principio pues parece que lo perdemos en cierta forma después, ¿no? Bueno, pues por eso, por eso el objetivo de hoy, teniendo en cuenta la ensalada de tecnologías que hemos apuntado al principio de la clase y teniendo en cuenta que, insisto, esta ensalada de tecnologías pues tiene como objetivo el, ¿cómo te diría yo? el daros solución y daros eh posibilidades y daros eh y abriros puertas y que podáis desarrollar prácticamente de todo y que todo lo hagáis con los lenguajes que más están pidiendo en las ofertas de empleo. Pero hoy, una vez que hemos puesto toda esta ensalada en la pantalla, mi objetivo es este que os acabo de poner. Es decir, vamos a pegar un repaso a C más. Empezamos ya en el segundo trimestre a verlo. Hoy vamos a realizar repasar ese repaso inicial de cuáles son los bloques constructivos del lenguaje C+ más y a partir de ahí vamos a hacer una serie de ejercicios en las 5 horas que tenemos por delante, sin contar la hora que tenéis de inglés, eh, para pues ver en qué escenarios C++ puede ser útil o incluso en un momento dado puede ser en algún escenario concreto incluso más útil que los lenguajes que habéis aprendido hasta el momento. Claro, los lenguajes que os he enseñado hasta el momento, como os digo, pues son lenguajes de bastante alto nivel. Es decir, si os fijáis tanto en PHP como en JavaScript, en el cliente y en el servidor, como en Python, pues al final estamos hablando de lenguajes de alto nivel, ¿vale? Donde nos hemos despreocupado de un montón de cosas. Eso, ¿qué quiere decir? pues que me da miedo que lleguéis a una entrevista de empleo y por lo que sea en la entrevista de empleo, pues se os requiera bajar un poquito más de nivel y que todo aquello que hemos visto en el ciclo, al menos en primero, esperaos también que queda el segundo por delante, pero al menos en primero, pues sea de haya sido de alto nivel, ¿vale? y en la empresa pues os lleguen a decir, "Oye, punteros, direcciones de memoria, eh, tipificación estricta de datos y se os quede cara de póker que digáis, espérate que esto no lo hemos visto en las clases." Vale, pues entre eso se acercan las prácticas de dual de primer curso y luego eso que esta mañana estaba repasando el tío B y en el tío B he visto que C+ vuelve a estar en segundo nivel más lo que os he comentado antes, ¿no? La suma de las variaciones de C. que prácticamente representa el o llega al 24%. Pues he dicho, "Oye, vamos a dedicar un rato en clase. Ya tenemos, como hemos visto estas semanas, estos meses, muy controlada la ensalada de tecnologías de la cual hablaba antes. Vamos a hacer algo un poquito más complejo, ¿vale? Ya os digo que cuando digo complejo no tengo ninguna necesidad como profesor de complicaros la vida. Por tanto, vais a ver que lo que vamos a hacer hoy requiere bajar un poquito, pero sobre todo lo que quiero es que si el día de mañana vais a la empresa y os dicen, "Oye, C, pues que no digáis, espérate que me acabo de en los pantalones", ¿vale? Sino que digáis, "Espérate, que esto es lo mismo, que ya sé, un poco más bajo, pero lo puedo hacer." ¿Vale? Bien, vamos a empezar con el fundamento. Así que antes de meternos en ejercicios concretos y en escenarios concretos, vamos a perderle el miedo. Esto ya lo hicimos en el segundo trimestre. Vamos a volverlo a hacer de nuevo. Como siempre, ya sabéis, me voy a ir a GitHub. Voy a crear un repositorio para que tengáis luego todo el código disponible. Eh, repositorios de C++. En mi cuenta de Jithub tengo Mogollón, con lo cual si pongo CPP me dirá que no está disponible. C++ no me deja usar el símbolo más. Claro, me lo crea como C gu- punto, o sea, tela. Vale, o sea, que no. Entonces, y si creo C++, pues me dirá que también existe. Es que tengo un montón de repositorios de estos. Así que, pues, mira, lo voy a llamar CPP 2025 y ya está. Ese no está pillado. Vale, pues le doy a Cre Repository. Ya sabéis que como siempre está abierto. Bien, me lo voy a clonar en mi equipo de desarrollo. Vale, entonces me voy a clone, me voy a FPP 2025. Y eh bueno, como siempre eh os voy a decir que yo voy a estar desarrollando los ejercicios de hoy con el mismo bloc de notas que utilizo siempre para enseñaros cualquier lenguaje, ¿vale? En mi caso es headit porque estoy en Linux, pero vosotros coged el entorno que queráis. Si estáis en Windows, que sepáis que existe el Visual Studio Community Edition que incorpora un compilador de C++ y también que sepáis que existe eh un programa que desgraciadamente suelo está para Windows, que está muy bien, que es el DEB CPP. El deb CPP, cuya página es esta de aquí, os la pongo en el chat, ¿vale? que tiene un micro entorno de desarrollo que está completamente focalizado para desarrollar en Curo y en C++ y que está muy guay. Ya os digo que si estuviera para Linux yo lo usaría en estos momentos ahora mismo, pero como no está para Linux pues desarrollo en bloc de notas. Entonces, igual no lo usaría para mí, pero sí que lo usaría para dar clase, porque de cara a vosotros pues es muy sencillo. Recordad que sí, en el caso de que estéis en Linux eh simplemente lo que tenéis que hacer es instalar las eh Essential Build Tools, ¿vale? Así que sudó app install y eh vamos a recordar el comando correcto. Vamos a ver eh GF Compiler Linux. Sí, G. Esto el Build Essential. Esto es, vale, en el caso de que estéis en Mac, que Luis creo recordar que tú estás en Mac, eh, simplemente tenéis que instalar o bien Xcode. Si por lo que sea hacéis algo para iOS, pues ya tendréis el Xcode instalado. O bien también Apple os ofrece una serie de build tools esenciales sin necesidad de instalar el Xcode completo, ¿vale? Con lo cual en Mac hay un truco y el truco es muy sencillo. Simplemente en el en una terminal de Mac pones GCC o pones G+. Si tienes instalado el compilador de C++ o de C puro, te dirá introduce un archivo para compilar. Y si no, Apple te sacará una ventanita. que te dirá, "Pincha aquí y te descargas las Essential Tools de Xcode", ¿vale? Con lo cual el truco es así de sencillo. Se pueden descargar también, obviamente, desde el portal de desarrolladores de Apple, pero con el truco de consola es mucho más rápido y mucho más sencillo. Y luego, en el caso de Windows, ya sabéis que la última vez que hablamos de esto os recomendé el pack de herramientas de Min GW. Entonces, el pack de herramientas de Min GW que está aquí, no, este no es, es este, el que está en source. Os paso por aquí por el chat la URL. Es el que os recomiendo instalar. Acordaos que hace unos pocos meses lo instalé en una máquina virtual con Windows 10. El pack de Min GW tiene un montón de lenguajes de programación. Yo os recomiendo instalar C puro y C++ y a partir de ahí, si queréis probar otros lenguajes como Objective C, como ada o como lo que sea, podéis hacerlo sin ningún tipo de problema. ¿Vale? Bien, a partir de aquí, a partir de aquí vamos a empezar con las bases, con los fundamentos. Entonces, me voy a ir a Headit y dentro de Hedit me voy a ir a HTML, me voy a ir a CPP 2025, ¿vale? y voy a crear una carpeta llamada fundamentos. Y dentro de fundamentos, pues vamos a crear en primer lugar archivo 001 y eh entrada.cpp. Sabéis que los archivos que tienen código con C++ deberían tener la extensión CPP. Hablaremos más adelante de que hay otros archivos que son cabeceras que tienen la extensión HPP, pero de momento nos quedamos con CPP. Además, lo que voy a hacer en este caso es abrir una terminal en esta carpeta. Así que, ¿dónde está? TPP 2025, fundamentos, botón derecho, abrir en una terminal. Pero antes de ello, vamos a verlo por aquí. Antes de ello, eh, a ver, aquí, vale, vamos a la plantilla mínima de trabajo con C++, que es esta que os estoy poniendo en la pantalla. Voy a hacer el tipo de letra un poco más grande y vamos a por ello. ¿Vale? Entonces, en primer lugar, así como en C puro importamos el STD IO, es decir, el estándar input and output, en C++ importamos el IOAM. Por tanto, en primer lugar, una directiva de inclusión mediante la cual incluimos la directiva de la librería de input en output, más que nada para tener los clásicos comandos de C out y C in, es decir, los clásicos comandos de salida y entrada. A continuación, en los lenguajes estructurados que hemos visto hasta ahora, no hacía falta tener un punto de entrada de ejecución. Es decir, simplemente en la línea número uno ponía sprint hola y el programa decía, "Bueno, pues tendré que empezar por aquí." Vimos en su momento que en Python, por ejemplo, existe la opción de poner un def main, ¿vale? donde puedes declarar manualmente cuál es el punto de entrada de la ejecución o el método principal al menos, pero no es obligatorio. Si no lo haces, el intérprete entiende que debe empezar por la primera línea en C+, en C y en el resto de lenguajes más cronológicamente antiguos, pues ese concepto no existe y debe ser declarado el punto de entrada de la ejecución. El punto de entrada es esta función. Más adelante os voy a enseñar que podéis crear las funciones que os dé la gana con el nombre que os dé la gana, pero siempre tiene que haber una función que se llame main. No se puede llamar de ninguna otra forma. Y además se recomienda que la función main sea la última que está en el código. Es decir, todas vuestras funciones están arriba, la main, la principal, aunque sea el punto de entrada de la ejecución, cosa que parecería indicarnos que debe estar arriba del todo, pero sin embargo no tiene que estar abajo del todo o se recomienda que esté abajo del todo. Siguiente cuestión. C++ es un lenguaje, perdón, eh, de tipificación estricta. Eso quiere decir que cuando declaras una función, esa función debe declarar el tipo de dato que va a devolver. En este caso, por defecto, está devolviendo int, lo cual quiere decir, y esto ya lo hemos visto anteriormente, que eh return cero, ¿vale? Si te comprometes a devolver un número entero, tienes que cumplir esa promesa y por tanto el return debe devolver un número entero. Eso es algo que a lo largo del curso os lo he indicado en otros lenguajes como buenas prácticas, es decir, crea funciones que tengan un punto de entrada y un punto de salida. Aquí no es una buena práctica, aquí es una obligación. O lo haces o tu programa no va a compilar. Y por último, una línea. Esta la podríamos quitar. Mira, de hecho, ¿sabes qué? La voy a quitar, ¿vale? Porque técnicamente no es parte del programa principal. Así que a continuación vamos a compilarlo. Lo voy a eh, esto queda, esto es entrada CPP. Okay, ahora sí. Vale, me voy aquí y en el compilador, pues básicamente lo que tengo que hacer es poner, un momento que haga esta ventana un poco más pequeña, ¿vale? Y poner eh GPP o perdón G+ y eh 001 y entrada CPP o como sea que se llame tu programa. Si tú no dices nada más, a continuación el programa al no tener información, el compilador, al no tener información de cómo quieres que se llame tu archivo de salida, en el caso de Linux y Mac, va a crear un archivo que se llama a punout out. En el caso de Windows, va a crear un archivo que se va a llamar a punexe. Otra cosa que puedes hacer es poner un comando de línea de ejecución que es gu o y decir salida.out. Le damos a enter y vemos como ahora debido a esto indicamos cuál es el nombre del archivo de salida. Otra cosa que podía hacer es sacar el a punout out y luego manualmente vía renombra, o sea, renombrado de línea de comando, renombrarle la puntua auta, lo que yo quiera. ¿Vale? Esto que acabo de hacer es un programa compilado, es un binario compilado que debería estar marcado como ejecutable. Lo cual quiere decir que si yo hago en el caso de Linux punto barra, en el caso de Windows no hace nada, no hace falta nada, simplemente pondría a punx y ya está. Pero en el caso de Linux de Mac o de las diferentes variaciones, sabores de Unix en las que podáis estar, pues tengo que poner punto barra para ejecutar un ejecutable. Así que ejecuto y no ocurre nada. No ocurre nada porque no tiene que ocurrir nada. También os digo que en el mundo de C y C++ el hecho de que no de un error ya es un avance, ya es algo, ¿vale? No, no hace nada porque me he cargado la línea del cout. Así que ahora a continuación voy a decir salida, ¿vale? Y ahora digo C out, lo cual viene a querer decir C va a sacar algo. Eh, a continuación, esto es lo que muchas veces a la gente le parece extraño. Eh, pongo menor que comillas porque voy a poner un literal. Pongo hola mundo desde C++ comillas para cerrar el literal. Y es recomendable que al final pongáis un STD. Es decir, de la librería estándar voy a utilizar el Nline. Por cierto, también voy a poner un STD en el Cout. Esto os lo explicaré más adelante que son los dos veces dos puntos. ¿Os acordáis que esto os lo comenté en PHP hace unas cuantas semanas que es el pamayim necutoim, es decir, dos veces dos puntos en hebreo, que es el operador de pertenencia, ¿vale? Que quiere decir de la librería STD. voy a utilizar el comando Cout de la librería STD voy a utilizar el comando en line, ¿vale? Enline, que básicamente es como el BR de HTML, es decir, te baja una línea. Vamos a probarlo. Así que voy a por rapidez voy a ignorar el flag out. Voy simplemente a compilar, ¿vale? Y ya está. Me lo va a compilar siempre como a pun out. Ey, ¿qué pasa? Bueno, pues pasa que me falta un punto y coma, el talón de aquiles de la programación y es que en otros muchos lenguajes tales como, bueno, en primer lugar, Python no hay punto y coma y en JavaScript pues si pones punto y coma y en PHP si pones punto y coma, bien, y si no lo pones bueno en PHP no tamban bien, ¿vale? Pero en JavaScript sí. C++ es un lenguaje de programación, de hecho, PHP deriva de C y DC+, en el cual estás obligado a poner punto y coma al final de cada instrucción, no al final de cada línea, como se suele decir, ¿vale? que es incompleto al final de cada instrucción, porque en una línea puede haber diferentes instrucciones. Otra cosa es que no es recomendable, pero puede haber varias instrucciones. Vale, ahora sí compilo. Okay. Eh, no news, good news. Es decir, si el programa compila y no dice nada es porque en principio no ha dado ningún error. Y ahora a continuación ejecuto a punout y me dice, "Hola, mundo desde C++." Vale, así que ya está. Tenemos nuestro primer programa que introduce algo de información. Esto es esto. Ah, claro, entrada el punto de entrada de la ejecución. Ahora, luego hablaremos de entradas, es decir, de cómo podemos introducir información como usuarios, como seres humanos dentro de C++. Vale, de momento vamos a empezar con lo típico, que si operadores, que si variables, que si estructuras de control, que si lo típico, insisto, para que no le tengáis miedo a hacer más y que entendáis que al final es lo mismo que ya sabéis. Vale, vengo por aquí y digo, ahora vamos a trabajar con operadores aritméticos. Entonces, eh, a continuación digo ST de out, voy a poner, pues, por ejemplo, 4 + 3. 4 + 3. Voy a ponerlo como yo calculo que esto dará error, eh, G++ 003, ¿vale? Pues mira, no ha dado error para fastidiar y me dice siete. Con lo cual con esto vamos a ver que los operadores aritméticos son los mismos que habéis visto en todos los lenguajes hasta el momento. El más es el operador de incremento, de adición, mejor dicho. El guion es la resta, el asterisco es la multiplicación, la barra que no la contrabarra es la división y el porcentaje es el resto entero de la división. Así que compilo, así que ejecuto y el resultado es igual que siempre, ¿vale? Eh, hay que tener en cuenta que a diferencia de otros lenguajes, por defecto en C++ estoy trabajando con números enteros. Por tanto, 4 di 3 en otros muchos lenguajes entiende que es un número flotante y nos dice 1.33333. Aquí nos dice 1. ¿Vale? Ahora, luego crearemos diferentes tipos de datos y veremos que también existen variables de tipo doubel, de tipo float y en definitiva variables con decimales. Bien, más cosas. 004 incrementos. Entonces, eh, bueno, no, espera, no he incrementos todavía porque para ello tengo que enseñar variables antes. Vamos a trabajar con operadores buleanos, ¿no? De comparación. Y ahora vamos a los buleanos. Estoy siguiendo, como ya sabéis, el mismo recorrido que sigo siempre. Entonces, quiero saber si es cierto que 4 es menor que 3. Así que G++ 004. Okay. Vale. Y eh ese es el problema, ¿vale? Y es que nos dice que esto es un int. Mientras que yo lo que quiero es tener un bulean. Voy a hacer una cosa. Voy a escribir bull eh 4 menor que 3. Bull, ¿qué? Pues bull comparación es igual a 4 es menor o igual que 3. Y aquí pongo comparación. Compilo. Okay. Y ahora ejecuto. Y me dice cer ya sabéis que es falso y uno es verdadero. Es cierto que 4 es menor que 3 o sea falso. Vale. Eh, podría claro, es que el cout no creo que me deje hacer esto. Vale, ahora comparación. Ahora hablamos de variables. Es mayor que tres. Y como siempre voy a ponerlo de siempre. 4 es menor o igual que 3. 4 es mayor o igual que 3. 4 es igual que 3. Doble igual. y 4 es no igual a 3. Compilo, ejecuto, ¿vale? Y me da el mismo resultado de siempre. Aquí es 011, mientras que en otros muchos lenguajes que hemos visto a lo largo del tiempo es false true, false true, false true. Pero básicamente es lo mismo. ¿Vale? A partir de aquí, ahora sí vamos a ver los operadores buleanos. Los operadores buleanos funcionan exactamente igual que lo que habéis visto anteriormente. Bar comparación es cierto que 4 es ig 4 doble ampers sand y que 3 es ig a 3. Ya sabéis que por buenas prácticas dejar espacios por aquí por el legibilidad más que nada. y 2 es ig 2. Vale, mira, es más, voy a hacer, voy a separar la declaración y la asignación. Vale, venga. Ahora, ¿es cierto que 4 es ig 4 y que 3 es ig a 3 y que 2 es ig a 1? Es falso. Vale, ahora es cierto que esto es el operador OR. El operador OR ya sabéis que es el doble pipe vertical. Entonces, ¿es cierto que 4 es ig 4 o que 3 es ig a 3 o que 2 es ig a 2? Será cierto. Ahora, ¿es cierto que 4 es ig 4 o que 3 es ig a 3 o que 2 es ig a 1? seguirá siendo cierto. Es cierto que 4 es ig 4 o que 3 es ig a 2 o que 2 es ig a 1. Seguirá siendo cierto, pero es cierto que 4 es ig 3 o que 3 es ig a 2 o que 2 es ig a 1? Pues no es cierto. ¿Vale? Entonces G++ 005 operadores buleanos A. Uy, espera. A punto out. Vale, esto es cierto. Esto e qué calma. A ver, aquí me dice uno, uno y uno. Ah, madre de Dios. Vale, esperad que me he rayado con los operadores. He puesto el OR en lugar de la igualdad. De hecho, no sé ni cómo ha reventado, o sea, ni cómo no ha reventado, perdón. Vale, vamos a poner los pipes en lugar de los ampersans. Esto me debería haber dado un error que te cagas, pero por algún motivo. Okay, vale, perfecto. Entonces, compilamos, ejecutamos. A ver, un momentín. Ah, vale. Compilamos el cinco. Ejecutamos. Ahora sí me da verdadero, verdadero, verdadero, falso. Vale, ahora sí que lo tenemos hasta el momento. En estos cinco primeros ejercicios, ¿cuál sería la conclusión que podemos sacar? Pues la conclusión es que aunque vemos que tiene más pijaditas, aunque vemos que tiene más recovecos, aunque vemos que es un lenguaje más sensible a los fallos, pero sin embargo es lo mismo que ya conocíamos, ¿vale? De hecho, los lenguajes que conocemos y que hemos venido utilizando, JavaScript y PHP, de hecho, están basados, ¿vale? Son simplificaciones abstraídas de más alto nivel que C y C++. Así que lo que estamos haciendo es el mismo camino en el que ya estábamos, pero bajar un poquito más profundo. Bien, vamos a continuar y eh vamos a trabajar ahora con la declaración de variables. El concepto de variable 006 variables es el mismo que ya conocíais, pero tiene un pequeño twist. Y el twist es que, tal y como os he comentado antes, las variables tienen que ser tipificadas. Yo voy a decir int edad es igual a 46. Esto quiere decir que cuando declaro una variable tengo que declarar el tipo de dato y evidentemente el tipo de dato debe estar de entre los tipos de datos legales soportados nativamente por C++ en este caso un número entero. Muy bien. Así que eh C out, bueno, STD C out doble menor que nunca me acostumbro, pero mira, es lo que hay, no podemos evitarlo. Tengo menor para encadenar edad menor años. Es como el operador de encadenamiento. Menor STD dos veces dos puntos new line. Espera, espérate que se me acaba de ir un poco la pinza. Endline, caray. Vale, así que compilamos G++ 006, ejecutamos, ¿vale? Y bueno, podría haberle puesto espacios y tengo 46 años. Lo que acabo de hacer es un momentín, compilo de nuevo. Vale, eso sí, estáis viendo que a diferencia de cualquier lenguaje interpretado de los que hemos visto hasta ahora, cada cambio que hago en el código fuente requiere una recompilación, ¿vale? Yo no puedo llamar, no puedo ejecutar directamente el código fuente, sino que tengo que convertir el código fuente a un archivo binario ejecutable y ejecutar el archivo binario. Y esto, insisto, como vamos a hablar durante la tarde de hoy, quizás también un trozo de la semana que viene, pues nos va a dar ventajas y nos va a dar desventajas. desventajas, que es un rollo con respecto a todo lo que hemos hecho hasta ahora, que ejecutábamos, interpretábamos directamente el código. Ventajas, el código que hagamos va a ser más rápido, va a ser más eficaz, más eficiente con respecto a los recursos que el que hemos hecho con otros lenguajes. ¿Os acordáis el otro día, el martes, de la gráfica que estuvimos haciendo de consumo por kilow hora y consumo por euros hora o por euros minuto de los programas informáticos que hemos desarrollado hasta el momento, pues el otro día, el martes os comentaba que una posibilidad es prototipar en Python y luego convertir a C++. Pues vamos a ver un poquito de C++, ¿vale? para que tengáis esa herramienta, para que tengáis esa posibilidad y para que no digáis, "Sí, vale, o sea, prototipo en Python eh, lo convierto hace más, pero no se hace más, ¿vale? Pues que veáis que no es un monstruo, no te come. Básicamente es un lenguaje de programación más difícil, sí, pero no es vuestro primer día en DAM. Estamos ya casi a final de curso, ya empezáis a estar preparados para este momento. Bien, eh vamos a declarar otros tipos de datos. 007, eh, altura variable altura. Entonces yo digo int altura es igual a 1.78, igual que en el resto de lenguajes de programación. Los decimales se declaran con el punto. Así que mido altura, mido metros. Claro, ¿qué ocurre? Pues que aquí el tipo de dato está mal, porque estoy declarando un tipo de dato entero para un dato que tiene decimales. A todas luces no es un número entero. G++ 007 variable. Parece que se lo ha comido, pero si yo a continuación ejecuto, vemos como no se lo ha comido y me dice mido 1 m. Hay algunos lenguajes o algunos compiladores incluso que hubieran dado error. En este caso, este compilador no ha dado error, pero básicamente no me ha hecho caso. Se ha cargado los decimales. Para ello, 008 eh tenemos los e los, o sea, los definidores de variable de tipo d, por ejemplo, o de tipo float. Voy a poner aquí decimales, así que voy a decir d altura es igual a 1,78 m. Y entonces a continuación compilo este programa 008, ejecuto, ay, perdón, ejecuto el programa y me ahora sí me dice mido 1,78 m. La siguiente pregunta que me podríais hacer sería, vale, ¿qué tipos de datos primitivos hay dentro de C++? Bueno, pues venimos por aquí y digo tipos de datos primitivos en C++ y Fran, por lo que preguntabas el otro día, ¿vale? Y la memoria que consume cada uno de esos tipos de datos. Vamos a verlos. ¿Vale? Entonces, para empezar, ¿vale? Para empezar, el tipo buleano consume, claro, un byte. También os digo una cosa, ¿vale? Insisto que este es, o sea, llega un momento en el que si os explico esto el primer día de clase, me hubieras mandado a la porra, pero estamos ya casi a final de curso, con lo cual ya es momento hablar de esto, ¿eh? Okay, pero en la tabla también quiero el consumo, no solo consumo, no solo en byes, sino también en builds. Vamos a verlo. Vale. Ah, pues mira, pues el bull, qué raro, no tenía yo noticia de esto, pero bueno, esto tengo que comprobarlo con la documentación, ¿vale? Pero tenemos el tamaño de, o sea, el tipo de dato bull buleano que consume un byte. Tenemos el tipo de dato char, que es capaz de alojar un solo carácter que consume un byte. Vale, esta tabla os la voy a poner por aquí en la documentación. Eh, aquí. Y esto lo voy a guardar. Hola. Lo voy a guardar como 009. Tipos de datos primitivos. Cuando digo primitivos quiero decir que son tipos de datos implementados en el core de C++, pero luego mediante librería se pueden añadir otros tipos de datos que obviamente en ese caso ya no son primitivos. ¿Vale? Tenemos el wild chart. Nada, olvidaros de esto de momento, ¿vale? Tenemos el short. El short es un entero corto que va de -32,000 a 32,000 y que ocupa solo 2 bytes en la memoria. A continuación tenemos elign short, que es como el tipo de datos short, no admite signo, lo cual quiere decir que en lugar de ir de -32,000 a 32,000 va de 0 a 65,000 y sigue ocupando dos bytes. Y luego tenemos el int, el integer y elign int que ocupa cuatro bytes y que puede ir desde -2000 millones hasta 2000 millones o de 0 a 4,000 millones. ¿Qué ha ocurrido antes? Pues lo que ha ocurrido antes es que yo he utilizado un campo de un tipo de dato int para almacenar una edad y una persona humana rara vez va a vivir más de, no sé, ¿sabes? 150 años. Esto quiere decir que he utilizado un campo int y he mal gastado memoria porque podría haber utilizado un campo short, habría gastado la mitad de la memoria y podría almacenar perfectamente el dato. En otros lenguajes de programación, estoy mirando por aquí, en otros lenguajes de programación hay un tipo de dato primitivo que es el byte, que va desde 0 hasta 25 y que por tanto, por ejemplo, en Java existe el byte, eh, y que por tanto, por ejemplo, para almacenar una edad sigue siendo un tipo de dato pues más conveniente todavía, ¿vale? Y evidentemente al ocupar un byte pues ocupa la mitad que un short. La cuestión está en que realmente esto que estoy comentando importa o no importa, ¿vale? Porque estamos hablando de gastar 4 bytes o estamos hablando de gastar 2 bytes en equipos informáticos que a día de hoy tienen, por ejemplo, este en el que estoy trabajando tiene, vamos a ver, espera que te lo digo, ¿no? Calculadora. Vale, este esto libre office fuera. Este equipo tiene GB multiplicado por 1024 son estos megab multiplicado por 1024 son estos kilbes multiplicado por 1024 son estos bytes. Es decir, en el equipo en el que estoy trabajando ahora mismo tengo 17,000 millones de beses. ¿Qué importa que gaste 4 bytes o que gaste 2 bytes? Porque tengo memoria de sobra. La cuestión está en que ya sabéis que de vez en cuando, no todos los días probablemente, ¿vale? Pero de vez en cuando hemos creado programas que no crean un dato, crean un array de datos y ese array puede tener una longitud que a lo largo del curso habéis visto que de vez en cuando esa longitud puede ser extremadamente grande. Para una variable no importa, pero cuando en una ray almacenas 10.000 variables, pues claro, gastar 4 bytes o gastar 2 bytes puede tener su importancia. ¿Vale? Acordaos que antes hablábamos de Rust en cuanto al tema de que implanta más medidas de producción con respecto a la memoria que, por ejemplo, C++. Si no tengo cuidado, si escojo mal mis tipos de datos, puedo hacer un uso incorrecto de la memoria, puedo desbordar la memoria cuando podría no haberla desbordado utilizando el tipo de dato correcto. ¿De quién es la culpa? ¿Del lenguaje de programación o del programador? Pues obviamente del programador, ¿vale? O esa es mi opinión. Bien. Así que voy a el ejemplo de la edad. Ah, ¿dónde estás? Aquí, ¿no? Y aquí y voy a decir 001 short, que la edad la podría haber declarado como short o como unsign short. Compilo G++ 010. ejecuto. Claro, qué manía con las mayúsculas. Ejecuto y vale y tengo 46 años. El programa ha funcionado exactamente igual de bien, pero he gastado la mitad de memoria en la variable que había utilizado anteriormente. Como veis, esto es un poco como Alicia en el país de las maravillas, ¿vale? Es lo mismo que ya sabíais, pero estamos indagando más, estamos bajando más, estamos vale, estamos profundizando más. Bien. Eh, hemos visto el bull, el Bueno, ahora os enseño el char, eh, hemos visto el int, ¿vale? Long, cuando almaceno números más grandes de, ¿dónde estás? Aquí de 4000 millones de unidades, ¿vale? En ese caso puedo utilizar el tipo de dato long. El tipo de dato long en este caso vamos a verlo. Vale, aunque aquí parece que no, pero mira, voy a usar el long. Parece un poquito de broma. Es como el pianista este chino, ¿vale? Que se llama Long. Pues eso, así que yo, por ejemplo, a continuación 011 error en tipo long o en tipo int, mejor dicho. Vale, voy a decir e no sé, int metros desde el Sol a la Tierra, yo que sé. Mira, ¿sabes qué? Voy a preguntárselo. Vamos a ver cuántos metros hay desde el Sol hasta la Tierra. Fantástico, ¿no? Fantástico. Eh, ¿cuántos milímetros? Uy, perdón. Vale, quería yo editar. Estoy un poco cuántos milímetros. Y okay, fantástico. Ahora sí. Muy bien. Entonces, supongamos que en eh Sol a Tierra creo una variable y le digo que tiene estos números de aquí. Eh, no, espérate, ahora esto sí, esto sí. Lo de antes eran el metros. Le quitamos los puntos porque para C++ un punto es un decimal, no vale como separador de centenas, millares, etcétera. Y hay sol a tierra milímetros. Intento compilar esto. G++ 011, ¿vale? Y no, no puedes, ¿vale? Sin embargo, sin embargo, fijaos que te dice, mira, si lo hubieras hecho con long int, sí que hubieras podido, ¿vale? Por tanto, yo vengo por aquí y digo, mira, en lugar de int, voy a usar un long. Le digo la tierra. Bueno, voy a hacer una cosa. Voy a guardar esto como uno nuevo. 012 tipo long. Ahora le pongo por aquí long. Compilo la siguiente versión 012. Vale, y compila correctamente y ya está. En principio podemos pensar que, bueno, que este ejemplo es propio de un escenario que a veces puede ser un poco extremo, pero no tiene por qué ser tan extremo. Recordaos que anteriormente durante este curso os he contado que en este año estoy colaborando con el proyecto este que os conté de la Universidad Politécnica de Valencia, que tiene que ver con respecto a cosmología y tiene que ver pues con cálculo de trayectorias y tiene que ver con una serie de cuestiones que requieren cálculos que realmente necesitan de esta precisión. Porque en el momento en el que empezamos a calcular distancias a una escala macroscópica, como es el universo, pues los ceros empiezan a sumar de forma bastante rápida. Con esto, ¿qué os quiero decir? Pues que no todos los días trabajas con números tan grandes como estos, pero tampoco es algo descabellado, ¿vale? Y viene bien tener un lenguaje de programación que tenga tipos de datos extendidos que tengan este soporte, gastando más memoria, evidentemente. Te vas ya. Bueno, hoy te has comido un rollo bastante, Espero que hayas desconectado. En fin, venga, hasta ahora a ti, tranquilo. Ah, sí, sí, sí, sí, eso, correcto. Sí, es que tiene truco. Vale, entonces vamos a ver, eh, en cuanto a consumo de memoria, ¿vale? Pues fijaos que un long está ocupando pues ocho byes, ¿vale? O sea, mucho más que todos los demás, pero bueno, si es necesario, si en un momento dado es necesario, pues oye, pues se utiliza y ya está. ¿Vale? Bien, luego tenemos el float, que se considera que es más eh más preciso, más grande que el long, porque fijaos que va de 3.4 exponencial a la -38 hasta más- 3.4 exponencial a la + 38, es decir, soporta hasta 38 posiciones decimales o 38 unidades numéricas, o sea, una barbaridad, ¿vale? Entonces, acordaos también que 013 float, cuando queremos trabajar con números muy grandes, también tenemos el float, el tipo de dato float G+ 013. Compilo, ¿vale? Claro, fijaos ahí que el float para abreviar me lo convierte anotación eh, caray, anotación científica, ¿vale? Pero bueno, al final es un número perfectamente entendible. Más 14 no pasa nada porque soporta hasta + 38, o sea, que tengo precisión ahí de sobra para dar y tomar. ¿Vale? Y luego tengo por ahí el double donde el double, atención, soporta 308. Es decir, vamos a ver, 014, precisión doble para números gigantescos, ¿vale? Nada, compilamos, compilamos 014 y ejecutamos, ¿vale? Y a puntu out y exactamente lo mismo. Bien, así que bueno, vamos a ver un poquito más la tabla a ver si hay alguno interesante. Long, ¿vale? La pregunta que podéis decir es, oye, ¿y dónde están los strings? ¿Cómo meto yo variables en cadena? La respuesta es no hay. ¿Vale? La respuesta es las cadenas no son un tipo de dato primitivo dentro de C++. Es curioso, pero es así. Sin embargo, sin embargo, por supuesto, vamos a ver que una de las grandes diferencias de C++ con respecto a C es que incorpora la librería de cadenas, que nos permite hacer lo siguiente, 05 eh cadena. Y entonces digo eh std string nombre es igual a José Vicente. Vamos a compilar por si me hace falta. incluir la librería de Strings. G+ 015, ¿vale? No, okay, perfecto. Bien. Y STD String apellidos es igual a Carratola Sanchez. Habrá un problema con el acento, pero bueno, no pasa nada. Así que std 2 barra out, bueno, voy a poner directamente nombre, apellidos. y eh STD New Line. ¿Será posible que me haya vuelto a olvidar endline? endline. Vale, compilamos G++ 015, ¿vale? Y ejecutamos y José Vicente Carratala Sánchez. Me faltaría meter ahí un espacio y ya está. Vale, pero da cuenta de que es de la librería estándar utilizo el tipo de dato string, no es un tipo de dato primitivo, pero bueno, da igual, utilizamos la librería estándar, la librería estándar tiene soporte para strings, pues problema solucionado, ¿vale? Simplemente es que tenéis que entender, al igual que ocurre, de hecho, en la mayoría de lenguajes en los que habéis trabajado hasta el momento, lo que pasa es que hasta el momento no os habéis dado cuenta de que realmente las cadenas en programación, en lenguajes de programación, no existen, son arrays de caracteres, ¿vale? Pero bueno, da igual. El caso es que podéis trabajar con cadenas y no hay ningún problema por ello y podéis trabajar como siempre lo habéis hecho. Bien, a partir de aquí, a partir de aquí eh hay algunos operadores más que os quiero enseñar una vez que hemos visto cadenas, ¿vale? Y vamos allá. Tenemos también los operadores eh aritméticos abreviados. Entonces, vamos a ver. Si yo digo que eh voy a dejarme esto. Si yo digo que int, tengo el operador aritmético abreviado de edad más igual a 5. Y en ese caso, mi edad es de más edad más años. Vamos a darle. G+ 016, ¿vale? Punto barra. Mi edad es de 51 años, es decir, sumamos 5 años. De la misma forma, edad menos igual a 5. Mi edad en este caso vuelve a ser de 46 años. Es decir, tenemos el operador aritmético abreviado de suma y de resta. Tenemos también el operador aritmético abreviado de multiplicación y de división. Así que compilamos, así que ejecutamos y aquí lo tenemos de nuevo. Básicamente un pequeño descansito, un refresco para que veáis que los operadores aritméticos abreviados son los mismos que ya conocíais en cualquier otro lenguaje de programación. Y ahora al ser eh un lenguaje que es C realmente pues tengo los operadores de incremento y decremento. Por supuesto, si el lenguaje se llama C++, pues tiene que soportar el operador de incremento, ¿vale? Entonces, edad más y edad menos. Mi edad es de 46 años. Compilo, ¿dónde estás? El 17. Ejecuto. Vale, sumo un año, resto un año. Solo se puede sumar de uno en uno. Si quieres sumar de dos en dos, ya no necesitas un operador de incremento, sino que lo que necesitas es un operador aritmético de suma abreviado. ¿Vale? Momentín. Okay, vale. Uh, ¿qué me dices? A ver, un segundo, a ver un segundo, que tengo un ordenador aquí al lado que me dice que me he quedado sin memoria. No es un falso. Nada. A ver. A ver, un segundo. A ver, un momentín que están comentando una cosa por aquí. Mm. A ver. Vale, entonces momentín ¿Por qué? A ver, qué raro. Esto no está actualizando. Esto no está actualizando. Qué raro que no actualice. Ah, muy bien. Ay, a ver, dame un segundo, porfa, un segundo. Y ahora continuamos con esto. Ay, a ver. Vale, bien. Entonces continuamos. Vale, pues eh teníamos ya los operadores de incremento. Vamos a ver. Vale, vamos a trabajar con eh estructuras de control, así que vamos al 018. Y en estructuras de control, pues sabéis que tenemos la, bueno, tenemos las estructuras de control de bucle, donde pues tenemos para empezar la estructura for. En Clara, int y, ¿sabes qué? Día. Entonces, día es igual a 0, mientras que día sea menor que 31, día más y entonces std si out eh hoy es el día más del mes y eh STD Endline. Vale, vamos a ejecutarlo. G++ 018. Y aquí lo tenemos. Y aquí tenemos la estructura de control de bucle que tenemos siempre, ¿vale? La de siempre. Tenemos también 019 estructura de control while. Cuidado, ¿vale? Cuidado porque eh intía while día sea menor que 31, pues ocurrirá esto. Esto va a dar un error. Esto va a dar un error porque G++ 019 y me dice al ejecutarlo me dice nada. Es decir, in día mientras que día sea menor que 31. Pero es que día no es nada, día no hace nada. Por tanto, porque ya no tiene valor, por tanto, no ejecuta en ningún momento el código. A continuación puedo decir 020 while inicializa. Entonces digo día es igual a 1. Compilo 020 contra barra a y como sabéis que ocurre siempre he entrado en un bucle infinito. He entrado en un bucle entre comillas descontrolado. Paro por aquí y por último 021 while correcto. Así que día más vengo por aquí G++ 021 llamo correctamente vale y ya está. Y luego tengo también la estructura de control do while. Es un poco rara, pero ahí está do while. Donde puedo decir eh día es igual a 40. Do estándar esto while condición, es decir, do see out. Hoy es el día uno del es el día x while día es menor que 31. Bien, lo que ocurre en este caso, vamos a verlo, es que dado que día es igual a cer nunca se debería ejecutar esto. Es decir, si yo ahora G++ 022, bueno, aparte de que en el do while hace falta un punto y coma, es la única estructura de control en la que hace falta un punto y coma, pero ejecuto y dice, "Hoy es el día 40 del mes. tú primero hace y luego se pregunta si lo tenía que haber hecho y en este caso no lo tenía que haber hecho, ¿vale? Con lo cual, pero ya lo ha hecho una vez. Hay algunas circunstancias concretas, hay algunos escenarios concretos en los cuales de vez en cuando puede venir bien que el sistema primero haga algo y luego ya si acaso para la siguiente ejecución del bucle se pregunte si no lo tenía que haber hecho, pero de momento ya lo he hecho una vez. Ya os digo, el campo de aplicación es muy estrecho, pero bueno, viene bien saber que la estructura de control pues está ahí. A continuación tenemos las estructuras de toma de decisiones, así que 023 toma de decisiones if. Y yo digo e int, pues no sé, ¿sabes? int edad es igual a 46, así que digo sí. Edad es menor que 30. En ese caso, STD, si out eres un joven y STD endline. Vale, lo ejecuto, lo compilo, lo ejecuto y no hace nada. Ey, me han faltado dos puntos. Vale, no, ¿qué pasa? STD otra vez dos puntos. Vale. Okay. Ejecuto. Hola. Compilo. Ah, sí. Y no dice nada porque es falso, por tanto, no se ejecuta el caso if. Vale, ahora 024 caso else. Si algo es cierto, ejecuta esto. Si algo es falso, ejecuta esto otro. Así que ya no eres un joven. G++ 024. Ejecuto. Y en este caso se ejecuta el caso falso y ya no eres un joven. Bien, a partir de aquí tenemos también el caso es el if. Así que caso els if. Y digo if. Vamos a ver. Si edad es menor que 10, eres un niño. Els if edad es mayor o igual que 10. Ampersand edad es menor que 20. En ese caso, STD, Cout, eres un adolescente. Els if 20 y 30 eres un joven y en cualquier otro caso ya no eres un joven, ¿vale? Por tanto, si pongo 26, pues es capaz de ejecutar el caso correcto y en este caso eres un joven. ¿Vale? Una vez más estamos viendo esta parte inicial antes de mandaros a inglés para que veáis que todo lo que sabéis hasta el momento es prácticamente igual, 95% igual a lo que ya sabíais de lenguajes anteriores. Y por tanto, mi misión en esta primera parte de la tarde de hoy es, insisto, que le perdáis el miedo a C más, ¿vale? Que veáis que es un lenguaje más exigente, más potente, más propenso a fallos, pero realmente es lo mismo que ya sabéis, ¿vale? Tenemos el Shift, tenemos también el caso switch, aunque el caso switch hay que cogerlo con un poquito de cuidado, ¿vale? Porque no se admite el switch en string. Sí que se admite, pero mediante una librería que es la librería String Compare. Ahora os lo cuento. ¿Vale? Entonces, vamos a ver. Eh, yo vengo por aquí y ahora a continuación digo, eh, intía de la semana es hoy es el día 4, hoy es jueves, así que digo switch día de la semana, aunque anteriormente hemos discutido acerca de que el switch técnicamente es un els if encubierto. ¿Vale? Entonces digo case 1, voy a el cout. Hoy es el peor día de la semana y acordaos que el case tiene que tener un break. Case 2 3 4 5 6 Momentín que me he cargado ahí algo. Si o aquí me he cargado un punto y coma. Aquí he puesto esto incorrecto. Vale. Cas 3 4 5 6 7 y este me sobra. Hoy es el segundo peor día. de la semana. Ya estamos a mitad de semana. Ya es casi viernes. Hoy es el mejor día de la semana y parece mentira que mañana ya sea lunes. Bien, pues a continuación compilamos esto. G+ 026. Ey, switch no es switch. Falta una T. Vale. Okay. A punto out. Y ya es casi viernes porque hoy es jueves. ¿Vale? Bien, con esto eh digamos que hemos finalizado las estructuras de control dentro de C++ y vamos a trabajar a continuación. Nos quedan unas cuantas, ¿vale? queda for each y todo eso, pero antes de explicaros for each, pues tengo que explicaros matrices o colecciones de datos, en definitiva, ¿vale? O estructuras de datos. Así que vamos con las funciones, luego iremos con los objetos y de ahí ya saltamos a estructuras de datos antes de enviaros a inglés y luego ya a la vuelta empezamos con los ejercicios, ¿vale? Pero un poquito el antes de que llegue ese momento sentar las bases y que veáis que pues no hay que tenerle miedo al lenguaje. Bien, vamos con funciones. Vamos a ver. Eh, funciones. De la misma forma que existe una función main, vosotros podéis crear vuestras funciones personalizadas. Así que digo eh int suma y entonces voy a decir eh out. Vamos a ver, digo int operando 1 es igual a 4. intando 2 es igual a 3. Y por tanto digo STD 2 pun cout. El resultado es, voy a poner int suma es igual a operando 1 + operando 2 y el resultado es suma y std new line, no endline. Vale. Okay. Esto no va a hacer nada. Esto es definir una función. G+ 027. Vale. Ey, ¿qué pasa? Ah, claro, perdón. Y es que si yo defino que voy a devolver un int, tengo que devolver un int. Si no quiero devolver nada, existe una opción que es poner void, que es no voy a devolver nada. Y hago así y operando. ¿Por qué? ¿Por qué me das error aquí? Ah, y esto porque operando dos. Ahora sí tenía un espacio. Vale, ejecuto y no ocurre nada. No ocurre nada porque he declarado una función, pero no he llamado a la función. Pero yo ahora a continuación 027 uso de la función y entonces digo, voy a llamar a la función. Llamo a la ejecución de la función. Caray. Vale, esto es uso de la función, ¿vale? Y ah, no, espera. 027, no, esto es 028. 028 uso de la función G++ 02. ¡Epa! ¿Qué pasa? Ah, ¿qué? Ah, G++, ¿vale? G+ en minúsculas. 028, ¿vale? Suma punto y coma. ¿Veis? Esto es lo que os digo, un carácter que te dejas no funciona. ¿Vale? El resultado es siete. He hecho una función, pero esto es una guarrada. Es una función que crea parámetros por aquí por el medio, que vomita directamente en la consola cosas. Ya sabéis que las funciones no tienen que ser así, ¿vale? Las funciones tienen que funcionar con return, así que return. Y aquí lo que hago es que return suma. Esto me lo cargo y como estoy devolviendo un número entero, aquí pongo intolver ahí int ahora digo std see out y suma, por ejemplo, y stdline. Vale, y ya está. Bien, vamos a por ello. G++ y 029 y ey, ¿qué pasa? Return suma punto y coma. ¿Qué hará con los puntos y coma? Vale, ya lo tenemos. Okay. Y me devuelve siete. Esta función es un poquito más limpia porque es una función que no vomita nada directamente en la consola, sino que devuelve un número y ya será la función principal, la que se encargue de decir si esto va a la consola o va a un archivo o va a una base de datos o va a dónde puñetas va. Bien. Siguiente cuestión. Las funciones 030 pueden contener parámetros de las funciones. De esta forma, para que la suma sea más interactiva, yo entonces vengo y digo suma de 4,3 y perdona, perdón que 4,3 a com b y digo para operando uno es a operando 2 es b y ya está. Por tanto, aquí pongo 4,3 G++ 030. A ver qué te ocurre. Ah, sí, espérate, espérate, espérate. Eh, suma int a int b. También hay que declarar el tipo de dato del parámetro, ¿vale? Y a punto outlar. ¿Qué ocurre? que una vez que he declarado parámetros, yo puedo aquí poner pues 3 y 67, yo que sé, lo que sea. Compilo, ejecuto y me lo devuelve correctamente. ¿Vale? Así que veis que en un momento dado pues crear funciones es igual de fácil y tiene la misma mecánica y sigue las mismas reglas que todo lo que habéis visto anteriormente en cualquier otro lenguaje de programación. Vale, voy a hacer un momento, una pausa.